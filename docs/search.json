[
  {
    "objectID": "Базы_данных_Алгоритмы_поиска.html",
    "href": "Базы_данных_Алгоритмы_поиска.html",
    "title": "\n8  Алгоритмы поиска\n",
    "section": "",
    "text": "8.1 Blast",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Алгоритмы поиска</span>"
    ]
  },
  {
    "objectID": "Базы_данных_Алгоритмы_поиска.html#blast",
    "href": "Базы_данных_Алгоритмы_поиска.html#blast",
    "title": "\n8  Алгоритмы поиска\n",
    "section": "",
    "text": "8.1.1 Скачиваем BLAST\n\nconda install -c conda-forge -c bioconda blast \nconda install -c bioconda entrez-direct\n\n\n8.1.2 Скачивание генома E. coli (референс)\n\nefetch -db nuccore -id NC_000913.3 -format fasta \\\n&gt; Структуры_данных/15.10.25/Ecoli_K12_MG1655_NC_000913_3.fna\n\n\n8.1.3 Индексирование референса\n\nmakeblastdb -in Структуры_данных/15.10.25/Ecoli_K12_MG1655_NC_000913_3.fna \\\n    -dbtype nucl \\\n    -parse_seqids \\\n    -title \"ecoli\" \\\n    -out Структуры_данных/15.10.25/ecoli_k12_nc000913\n\n\n\nBuilding a new DB, current time: 12/25/2025 13:14:40\nNew DB name:   /Users/lidaflorenskaya/Documents/АлгБио/1_sem/1_sem_algbio_book/Структуры_данных/15.10.25/ecoli_k12_nc000913\nNew DB title:  ecoli\nSequence type: Nucleotide\nDeleted existing Nucleotide BLAST database named /Users/lidaflorenskaya/Documents/АлгБио/1_sem/1_sem_algbio_book/Структуры_данных/15.10.25/ecoli_k12_nc000913\nKeep MBits: T\nMaximum file size: 1000000000B\nAdding sequences from FASTA; added 1 sequences in 0.103826 seconds.\n\n\nЗапуск поиска BLAST:\n\nblastn -query 'Структуры_данных/15.10.25/gene (1).fasta' \\\n-db Структуры_данных/15.10.25/ecoli_k12_nc000913 \\\n-out Структуры_данных/15.10.25/gene_vs_ecoli.tsv \\\n-outfmt \"6 qseqid sseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore\" \\\n-evalue 1e-10 -max_target_seqs 10 -num_threads 1\n\n\ncat Структуры_данных/15.10.25/gene_vs_ecoli.tsv\n\nV00296.1    ref|NC_000913.3|    99.935  3078    2   0   1   3078    366302  363225  0.0 5674",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Алгоритмы поиска</span>"
    ]
  },
  {
    "objectID": "Базы_данных_Алгоритмы_поиска.html#sra",
    "href": "Базы_данных_Алгоритмы_поиска.html#sra",
    "title": "\n8  Алгоритмы поиска\n",
    "section": "\n8.2 SRA",
    "text": "8.2 SRA\nSRA Run/File Selector\nInstall NCBI SRA Toolkit\n\ncurl --output sratoolkit.tar.gz https://ftp-trace.ncbi.nlm.nih.gov/sra/sdk/current/sratoolkit.current-mac64.tar.gz\ntar -vxzf sratoolkit.tar.gz\n\n\nconda install sra-tools\n\n\n# Путь к файлу со списком SRA-идентификаторов\nLIST_FILE=\"Структуры_данных/15.10.25/SRR_Acc_List.txt\"\n\n# Папки для хранения скачанных .sra-файлов и итоговых FASTQ\nSRA_DIR=\"Структуры_данных/15.10.25/sra_downloads\"\nFASTQ_DIR=\"Структуры_данных/15.10.25/fastq_files\"\n\nmkdir -p \"${SRA_DIR}\" \"${FASTQ_DIR}\"\n\nwhile read SRR_ID; do\n  echo \"$SRR_ID\"\n  prefetch \"${SRR_ID}\" -O \"${SRA_DIR}\"\n  fasterq-dump \"${SRR_ID}\" --outdir \"${FASTQ_DIR}\" --split-files --skip-technical --threads 1\ndone &lt; \"${LIST_FILE}\"\n\nDoesnt work…",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Алгоритмы поиска</span>"
    ]
  },
  {
    "objectID": "Базы_данных_белковые_БД.html",
    "href": "Базы_данных_белковые_БД.html",
    "title": "\n9  Белковые базы данных\n",
    "section": "",
    "text": "9.1 Построение HMM модели\nUniprot Q9Y5N5 Q5TIJ2 - тест UniprotKB\nhhmer",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Белковые базы данных</span>"
    ]
  },
  {
    "objectID": "Базы_данных_белковые_БД.html#построение-hmm-модели",
    "href": "Базы_данных_белковые_БД.html#построение-hmm-модели",
    "title": "\n9  Белковые базы данных\n",
    "section": "",
    "text": "Чтобы обучить модель, нужно сначала построить множественнное выравнивание test на train с помощью muscle\n\n\nTRAIN='Структуры_данных/29.10.25/sem4/train.fasta'\nmuscle -align \"$TRAIN\" -output Структуры_данных/29.10.25/demo_aln.fasta\n\n\nmuscle 5.3.osx64 []  8.6Gb RAM, 4 cores\nBuilt Jul 30 2025 21:35:18\n(C) Copyright 2004-2021 Robert C. Edgar.\nhttps://drive5.com\n\n[align Структуры_данных/29.10.25/sem4/train.fasta]\nInput: 5 seqs, avg length 269, max 366, min 245\n\n00:00 2.3Mb    20.0% Derep 1 uniques, 0 dupes\n00:00 2.3Mb   100.0% Derep 4 uniques, 1 dupes\n00:00 2.3Mb  CPU has 4 cores, running 4 threads\n00:00 2.4Mb    16.7% Calc posteriors\n00:00 16Mb    100.0% Calc posteriors\n00:00 16Mb     33.3% UPGMA5         \n00:00 16Mb    100.0% UPGMA5\n00:00 16Mb     16.7% Consistency (1/2)\n00:00 16Mb    100.0% Consistency (1/2)\n00:00 16Mb     16.7% Consistency (2/2)\n00:00 16Mb    100.0% Consistency (2/2)\n00:00 16Mb      1.0% Refining         \n00:00 16Mb    100.0% Refining\n\n\n\necho \"Output:\"\ncat Структуры_данных/29.10.25/demo_aln.fasta\n\nOutput:\n&gt;UniRef100_A0A212D384 C1QC n=1 Tax=Cervus elaphus hippelaphus TaxID=46360 RepID=A0A212D384_CEREH\nMESAPGPPGWVHSDTAYACLGEGKPVRGPLRDQTGHLPPIQVDMGSGAWRLLVLNLLLLLLARPLRGQAGTHCYGIPGMP\nGLPGAPGKDGYDGLPGPKGEPEGKPVRGPLRDQTGHLPPIQVDMGSGAWRLLVLNLLLLLLARPLRGQAGTHCYGIPGMP\nGLPGAPGKDGYDGLPGPKGEPGIPATPGTRGPKGQKGDPGTPGYPGKNGPMGTPGIPGTPGTMGPPGEPGVEGRYKQKHQ\nSVFSVTRQTVQFPAANSLVKFNEIITNPQGHYDRDTGKFTCKVPGLYYFVFHTSHTSNLCVLLFRSGFKVATFCDHMTSS\nKQVSSGGVLLRMQEGQQVWLAVNDYNGMVGTGGSDSVFSGFLLFPD\n&gt;tr|F7HEL0|F7HEL0_MACMU Complement C1q C chain OS=Macaca mulatta OX=9544 GN=C1QC PE=2 SV=1\nM-------------------------------------------------------------------------------\n------------------------------------------DVGPSSLPHLGLKLLLLLLLLPLRGQANTGCYGIPGMP\nGLPGAPGKDGHDGLPGPKGEPGIPAIPGTRGPKGQKGEPGTPGHPGKNGPMGPPGMPGVPGPMGIPGEPGEEGRYKQKYQ\nSVFTVARQTHQPPAPNSLIRFNAVLTNPQGDYDTSTGKFTCKVPGLYYFVYHASHTANLCVLLYRGGVKVVTFCGHTSQA\nNQVNSGGVLLRLQVGEEVWLGVNDYYDMVGIQGSDSVFSGFLLFPD\n&gt;tr|A0A2K5WNV2|A0A2K5WNV2_MACFA C1q domain-containing protein OS=Macaca fascicularis OX=9541 GN=EGM_00326 PE=4 SV=1\nM-------------------------------------------------------------------------------\n------------------------------------------DVGPSSLPHLGLKLLLLLLLLPLRGQANTGCYGIPGMP\nGLPGAPGKDGHDGLPGPKGEPGIPAIPGTRGPKGQKGEPGTPGHPGKNGPMGPPGMPGVPGPMGIPGEPGEEGRYKQKYQ\nSVFTVARQTHQPPAPNSLIRFNAVLTNPQGDYDTSTGKFTCKVPGLYYFVYHASHTANLCVLLYRGGVKVVTFCGHTSQA\nNQVNSGGVLLRLQVGEEVWLGVNDYYDMVGIQGSDSVFSGFLLFPD\n&gt;tr|A0A2J8K450|A0A2J8K450_PANTR Adiponectin B OS=Pan troglodytes OX=9598 GN=ADIB PE=4 SV=1\nM-------------------------------------------------------------------------------\n------------------------------------------DMGPSSLPHLGLKLLLLLLLLPLRGQANTGCYGIPGMP\nGLPGAPGKDGYDGLPGPKGEPGIPAIPGIRGPKGQKGEPGLPGHPGKNGPMGPPGMPGVPGPMGIPGEPGEEGRYKQKFQ\nSVFTVARQTHQPPAPNSLIRFNAVLTNPQGDYDTSTGKFTCKVPGLYYFVYHASHTANLCVLLYRSGVKVVTFCGHTSKT\nNQVNSGGVLLRLQVGEEVWLAVNDYYEMVGIQGSDSVFSGFLLFPD\n&gt;tr|A0A024RAA7|A0A024RAA7_HUMAN Adiponectin B OS=Homo sapiens OX=9606 GN=ADIB PE=4 SV=1\nM-------------------------------------------------------------------------------\n------------------------------------------DVGPSSLPHLGLKLLLLLLLLPLRGQANTGCYGIPGMP\nGLPGAPGKDGYDGLPGPKGEPGIPAIPGIRGPKGQKGEPGLPGHPGKNGPMGPPGMPGVPGPMGIPGEPGEEGRYKQKFQ\nSVFTVTRQTHQPPAPNSLIRFNAVLTNPQGDYDTSTGKFTCKVPGLYYFVYHASHTANLCVLLYRSGVKVVTFCGHTSKT\nNQVNSGGVLLRLQVGEEVWLAVNDYYDMVGIQGSDSVFSGFLLFPD\n\n\n\nСтроим модель\n\n\nhmmbuild -n DEMO_PROFILE Структуры_данных/29.10.25/demo_profile.hmm Структуры_данных/29.10.25/demo_aln.fasta \n\n# hmmbuild :: profile HMM construction from multiple sequence alignments\n# HMMER 3.4 (Aug 2023); http://hmmer.org/\n# Copyright (C) 2023 Howard Hughes Medical Institute.\n# Freely distributed under the BSD open source license.\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n# input alignment file:             Структуры_данных/29.10.25/demo_aln.fasta\n# output HMM file:                  Структуры_данных/29.10.25/demo_profile.hmm\n# name (the single) HMM:            DEMO_PROFILE\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n# idx name                  nseq  alen  mlen eff_nseq re/pos description\n#---- -------------------- ----- ----- ----- -------- ------ -----------\n1     DEMO_PROFILE             5   366   245     0.41  0.585 \n\n# CPU time: 0.14u 0.01s 00:00:00.15 Elapsed: 00:00:00.16\n\n\n\necho \"Model:\"\nhead -20 Структуры_данных/29.10.25/demo_profile.hmm\n\nModel:\nHMMER3/f [3.4 | Aug 2023]\nNAME  DEMO_PROFILE\nLENG  245\nALPH  amino\nRF    no\nMM    no\nCONS  yes\nCS    no\nMAP   yes\nDATE  Thu Dec 25 10:22:59 2025\nNSEQ  5\nEFFN  0.405273\nCKSUM 3271082919\nSTATS LOCAL MSV      -11.0624  0.70319\nSTATS LOCAL VITERBI  -11.7943  0.70319\nSTATS LOCAL FORWARD   -5.5339  0.70319\nHMM          A        C        D        E        F        G        H        I        K        L        M        N        P        Q        R        S        T        V        W        Y   \n            m-&gt;m     m-&gt;i     m-&gt;d     i-&gt;m     i-&gt;i     d-&gt;m     d-&gt;d\n  COMPO   2.60034  4.11646  3.02860  2.91582  3.29415  2.32280  3.78234  2.94540  2.80972  2.43041  3.68580  3.15881  2.84392  3.18382  3.08263  2.69099  2.87652  2.64704  4.82526  3.43607\n          2.68618  4.42225  2.77519  2.73123  3.46354  2.40513  3.72494  3.29354  2.67741  2.69355  4.24690  2.90347  2.73739  3.18146  2.89801  2.37887  2.77519  2.98518  4.58477  3.61503",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Белковые базы данных</span>"
    ]
  },
  {
    "objectID": "Базы_данных_белковые_БД.html#скан-модели-против-последовательности",
    "href": "Базы_данных_белковые_БД.html#скан-модели-против-последовательности",
    "title": "\n9  Белковые базы данных\n",
    "section": "\n9.2 Скан модели против последовательности",
    "text": "9.2 Скан модели против последовательности\n\nDB='Структуры_данных/29.10.25/sem4/test.fasta'\n\nhmmsearch --cpu 1 --tblout Структуры_данных/29.10.25/hmmsearch_tblout.tsv \\\n--domtblout Структуры_данных/29.10.25/hmmsearch_domtblout.tsv \\\nСтруктуры_данных/29.10.25/demo_profile.hmm \"$DB\" \\\n&gt; Структуры_данных/29.10.25/hmmsearch_output.txt\n\n\necho 'hmmsearch_tblout.tsv'\ncat Структуры_данных/29.10.25/hmmsearch_tblout.tsv\n\nhmmsearch_tblout.tsv\n#                                                               --- full sequence ---- --- best 1 domain ---- --- domain number estimation ----\n# target name        accession  query name           accession    E-value  score  bias   E-value  score  bias   exp reg clu  ov env dom rep inc description of target\n#------------------- ---------- -------------------- ---------- --------- ------ ----- --------- ------ -----   --- --- --- --- --- --- --- --- ---------------------\nUniRef50_A0A7L0WEH7  -          DEMO_PROFILE         -           1.3e-102  329.7  12.4  1.4e-102  329.6  12.4   1.0   1   0   0   1   1   1   1 C1QC protein (Fragment) n=1 Tax=Alectura lathami TaxID=81907 RepID=A0A7L0WEH7_ALELA\nUniRef90_A0A0C4W3E5  -          DEMO_PROFILE         -            3.3e-54  171.2  10.2     4e-54  170.9  10.2   1.0   1   0   0   1   1   1   1 C1qC protein n=4 Tax=Petromyzontidae TaxID=7746 RepID=A0A0C4W3E5_9PETR\n#\n# Program:         hmmsearch\n# Version:         3.4 (Aug 2023)\n# Pipeline mode:   SEARCH\n# Query file:      Структуры_данных/29.10.25/demo_profile.hmm\n# Target file:     Структуры_данных/29.10.25/sem4/test.fasta\n# Option settings: hmmsearch --tblout Структуры_данных/29.10.25/hmmsearch_tblout.tsv --domtblout Структуры_данных/29.10.25/hmmsearch_domtblout.tsv --cpu 1 Структуры_данных/29.10.25/demo_profile.hmm Структуры_данных/29.10.25/sem4/test.fasta \n# Current dir:     /Users/lidaflorenskaya/Documents/АлгБио/1_sem/1_sem_algbio_book\n# Date:            Thu Dec 25 10:23:07 2025\n# [ok]\n\n\n\necho 'hmmsearch_domtblout.tsv'\ncat Структуры_данных/29.10.25/hmmsearch_domtblout.tsv\n\nhmmsearch_domtblout.tsv\n#                                                                            --- full sequence --- -------------- this domain -------------   hmm coord   ali coord   env coord\n# target name        accession   tlen query name           accession   qlen   E-value  score  bias   #  of  c-Evalue  i-Evalue  score  bias  from    to  from    to  from    to  acc description of target\n#------------------- ---------- ----- -------------------- ---------- ----- --------- ------ ----- --- --- --------- --------- ------ ----- ----- ----- ----- ----- ----- ----- ---- ---------------------\nUniRef50_A0A7L0WEH7  -            213 DEMO_PROFILE         -            245  1.3e-102  329.7  12.4   1   1  9.3e-103  1.4e-102  329.6  12.4    32   244     1   213     1   213 1.00 C1QC protein (Fragment) n=1 Tax=Alectura lathami TaxID=81907 RepID=A0A7L0WEH7_ALELA\nUniRef90_A0A0C4W3E5  -            241 DEMO_PROFILE         -            245   3.3e-54  171.2  10.2   1   1   2.6e-54     4e-54  170.9  10.2    13   244     6   240     2   241 0.85 C1qC protein n=4 Tax=Petromyzontidae TaxID=7746 RepID=A0A0C4W3E5_9PETR\n#\n# Program:         hmmsearch\n# Version:         3.4 (Aug 2023)\n# Pipeline mode:   SEARCH\n# Query file:      Структуры_данных/29.10.25/demo_profile.hmm\n# Target file:     Структуры_данных/29.10.25/sem4/test.fasta\n# Option settings: hmmsearch --tblout Структуры_данных/29.10.25/hmmsearch_tblout.tsv --domtblout Структуры_данных/29.10.25/hmmsearch_domtblout.tsv --cpu 1 Структуры_данных/29.10.25/demo_profile.hmm Структуры_данных/29.10.25/sem4/test.fasta \n# Current dir:     /Users/lidaflorenskaya/Documents/АлгБио/1_sem/1_sem_algbio_book\n# Date:            Thu Dec 25 10:23:07 2025\n# [ok]\n\n\n\necho 'hmmsearch_output.txt'\ncat Структуры_данных/29.10.25/hmmsearch_output.txt\n\nhmmsearch_output.txt\n# hmmsearch :: search profile(s) against a sequence database\n# HMMER 3.4 (Aug 2023); http://hmmer.org/\n# Copyright (C) 2023 Howard Hughes Medical Institute.\n# Freely distributed under the BSD open source license.\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n# query HMM file:                  Структуры_данных/29.10.25/demo_profile.hmm\n# target sequence database:        Структуры_данных/29.10.25/sem4/test.fasta\n# per-seq hits tabular output:     Структуры_данных/29.10.25/hmmsearch_tblout.tsv\n# per-dom hits tabular output:     Структуры_данных/29.10.25/hmmsearch_domtblout.tsv\n# number of worker threads:        1\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nQuery:       DEMO_PROFILE  [M=245]\nScores for complete sequences (score includes all domains):\n   --- full sequence ---   --- best 1 domain ---    -#dom-\n    E-value  score  bias    E-value  score  bias    exp  N  Sequence            Description\n    ------- ------ -----    ------- ------ -----   ---- --  --------            -----------\n   1.3e-102  329.7  12.4   1.4e-102  329.6  12.4    1.0  1  UniRef50_A0A7L0WEH7  C1QC protein (Fragment) n=1 Tax=Alectura\n    3.3e-54  171.2  10.2      4e-54  170.9  10.2    1.0  1  UniRef90_A0A0C4W3E5  C1qC protein n=4 Tax=Petromyzontidae Tax\n\n\nDomain annotation for each sequence (and alignments):\n&gt;&gt; UniRef50_A0A7L0WEH7  C1QC protein (Fragment) n=1 Tax=Alectura lathami TaxID=81907 RepID=A0A7L0WEH7_ALELA\n   #    score  bias  c-Evalue  i-Evalue hmmfrom  hmm to    alifrom  ali to    envfrom  env to     acc\n ---   ------ ----- --------- --------- ------- -------    ------- -------    ------- -------    ----\n   1 !  329.6  12.4  9.3e-103  1.4e-102      32     244 ..       1     213 []       1     213 [] 1.00\n\n  Alignments for each domain:\n  == domain 1  score: 329.6 bits;  conditional E-value: 9.3e-103\n         DEMO_PROFILE  32 cygipgmpglpgapgkdgydglpgpkgepgipaipgirgpkgqkgepglpghpgkngpmgppglpgvpgpmgipgepgeegrykqkyqsv 121\n                          cyg pg+pg+pg pg+dg dgl g kgepgipa p +rgpkg kgepg pg pgk gp g pg pg pg mg  g pg  g ykqk+qs \n  UniRef50_A0A7L0WEH7   1 CYGAPGLPGMPGVPGRDGRDGLKGAKGEPGIPAPPATRGPKGMKGEPGSPGLPGKTGPTGLPGPPGDPGVMGAAGAPGLLGSYKQKHQSA 90 \n                          9***************************************************************************************** PP\n\n         DEMO_PROFILE 122 ftvarqthqppapnslirfnavltnpqgdydtstgkftckvpglyyfvyhashtanlcvllyrsgvkvvtfcghtskanqvnsggvllrl 211\n                          f+v+r+t + p  n+ + fn+++tn + d+dt+tgkftck+pglyyfv+h+s+t nlcv+ly+   ++++fc+h +++ qv+sggvll l\n  UniRef50_A0A7L0WEH7  91 FSVTRKTAEHPLKNTPVVFNNIITNTNKDFDTTTGKFTCKLPGLYYFVFHSSQTGNLCVILYKDHSRMASFCDHKTNTMQVSSGGVLLHL 180\n                          ****************************************************************************************** PP\n\n         DEMO_PROFILE 212 qvgeevwlavndyydmvgiqgsdsvfsgfllfp 244\n                          q g++vwl vndy++mvgi+gsdsvfsgfllfp\n  UniRef50_A0A7L0WEH7 181 QAGNQVWLEVNDYNGMVGIGGSDSVFSGFLLFP 213\n                          ********************************9 PP\n\n&gt;&gt; UniRef90_A0A0C4W3E5  C1qC protein n=4 Tax=Petromyzontidae TaxID=7746 RepID=A0A0C4W3E5_9PETR\n   #    score  bias  c-Evalue  i-Evalue hmmfrom  hmm to    alifrom  ali to    envfrom  env to     acc\n ---   ------ ----- --------- --------- ------- -------    ------- -------    ------- -------    ----\n   1 !  170.9  10.2   2.6e-54     4e-54      13     244 ..       6     240 ..       2     241 .] 0.85\n\n  Alignments for each domain:\n  == domain 1  score: 170.9 bits;  conditional E-value: 2.6e-54\n         DEMO_PROFILE  13 lkllllllllplrg..qantgcygipgmpglpgapgkdgydglpgpkgepgipaipgirgpkgqkgepglpghpgkngpmgppglpgvpg 100\n                          l lllll ++ + g  q +t c gi g+pg pgapg+ g  g pg  g  g    pg +g  g +g  g pg pgk gp+g+pgl g+pg\n  UniRef90_A0A0C4W3E5   6 LPLLLLLGVVVVVGaqQEKTVCAGINGIPGQPGAPGQHGTPGAPGRDGRDGATGAPGAKGDLGARGLTGDPGLPGKLGPLGQPGLAGTPG 95 \n                          4555555554444433889****************************************************************9977776 PP\n\n         DEMO_PROFILE 101 pmgipgepgeegr...ykqkyqsvftvarqthqppapnslirfnavltnpqgdydtstgkftckvpglyyfvyh.ashtanlcvllyrsg 186\n                            g  ge ge+g+        +s f+  +     pa+ s + fn ++tnpqg+y+  tgkftc  pg+yyf     sh   l+v+++ +g\n  UniRef90_A0A0C4W3E5  96 VPGEQGERGEKGKrgeSGVGPRSAFSA-KVGAYKPAAGSPVTFNVIITNPQGHYNPGTGKFTCAHPGVYYFTLNmHSHEQSLVVMIMTNG 184\n                          666666666666500055567899985.566678999**********************************875269************* PP\n\n         DEMO_PROFILE 187 vkvvtfcghtskanqvnsggvllrlqvgeevwlavnd.yydmvgiqgsdsvfsgfllfp 244\n                            +  +cg   +     sg v+l l+ g+evwl ++  y +++     dsvfsg++l+ \n  UniRef90_A0A0C4W3E5 185 NIISKVCGDKYD---AISGSVVLSLKAGDEVWLELEApYIHFLFDVHRDSVFSGYILYS 240\n                          *******98765...469****************98537888888899********986 PP\n\n\n\nInternal pipeline statistics summary:\n-------------------------------------\nQuery model(s):                            1  (245 nodes)\nTarget sequences:                          3  (1478 residues searched)\nPassed MSV filter:                         2  (0.666667); expected 0.1 (0.02)\nPassed bias filter:                        2  (0.666667); expected 0.1 (0.02)\nPassed Vit filter:                         2  (0.666667); expected 0.0 (0.001)\nPassed Fwd filter:                         2  (0.666667); expected 0.0 (1e-05)\nInitial search space (Z):                  3  [actual number of targets]\nDomain search space  (domZ):               2  [number of targets reported over threshold]\n# CPU time: 0.01u 0.01s 00:00:00.02 Elapsed: 00:00:00.01\n# Mc/sec: 30.48\n//\n[ok]",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Белковые базы данных</span>"
    ]
  },
  {
    "objectID": "Базы_данных_белковые_БД.html#поиск-последовательности-против-бд-моделей",
    "href": "Базы_данных_белковые_БД.html#поиск-последовательности-против-бд-моделей",
    "title": "\n9  Белковые базы данных\n",
    "section": "\n9.3 Поиск последовательности против БД моделей",
    "text": "9.3 Поиск последовательности против БД моделей\n\n\nСкачать модели Pfam\n\n\nwget -P 29.10.25 ftp://ftp.ebi.ac.uk/pub/databases/Pfam/current_release/Pfam-A.hmm.gz\ngunzip Структуры_данных/29.10.25/Pfam-A.hmm.gz\nhmmpress Структуры_данных/29.10.25/Pfam-A.hmm \n\nСлишком много весит…\n\nПо идее аннотируем последовательность\n\n\nhmmscan --cpu 1 --domtblout pfam.domtbl \\\nСтруктуры_данных/29.10.25/Pfam-A.hmm protein.fasta \\\n&gt; Структуры_данных/29.10.25/pfam_scan.txt",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Белковые базы данных</span>"
    ]
  },
  {
    "objectID": "Базы_данных_БД_трехмерных_структур.html",
    "href": "Базы_данных_БД_трехмерных_структур.html",
    "title": "\n10  БД трехмерных структур\n",
    "section": "",
    "text": "10.1 Парадигма биоинформатики\nСходство последовательности == сходство функций == родство Схожи гены и белки.\nНо функции обеспечивают именно структуры, а не просто последовательности",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>БД трехмерных структур</span>"
    ]
  },
  {
    "objectID": "Базы_данных_БД_трехмерных_структур.html#первичная-и-вторичная-структура",
    "href": "Базы_данных_БД_трехмерных_структур.html#первичная-и-вторичная-структура",
    "title": "\n10  БД трехмерных структур\n",
    "section": "\n10.2 Первичная и вторичная структура",
    "text": "10.2 Первичная и вторичная структура\n\nПервичная - одномерная лиинейная последовательность аминокислот\nВторичная - двумерное расположение элементов структуры. У ДНК мало элементов вторичной структуры, у РНК - много всего - шпильки, узлы и тд, а у белков - меньше, чнм у РНК:\n\nАльфа-спираль\nБета-лист\nПетля (чаще встречается пролин)\n\n\nТретичная - трехмерная структура в пространстве. Как она определяется и хранится? Это тема сегодняшней лекции\nЧетвертичная - четвертичная полидоменная структура из нескольких последовательностей.",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>БД трехмерных структур</span>"
    ]
  },
  {
    "objectID": "Базы_данных_БД_трехмерных_структур.html#ямр",
    "href": "Базы_данных_БД_трехмерных_структур.html#ямр",
    "title": "\n10  БД трехмерных структур\n",
    "section": "\n10.3 ЯМР",
    "text": "10.3 ЯМР\nЯдра с ненулевым спином в сильном постоянном магнитной поле возбуждаются импульсами и регистрируются их резонансные переходы\n\nИсследует гибкие белки\nПрименяется к белкам до 40 кДа\nИспользуются меченые изотопами образцы",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>БД трехмерных структур</span>"
    ]
  },
  {
    "objectID": "Базы_данных_БД_трехмерных_структур.html#pca-ренгтгенно-структурный-анализ",
    "href": "Базы_данных_БД_трехмерных_структур.html#pca-ренгтгенно-структурный-анализ",
    "title": "\n10  БД трехмерных структур\n",
    "section": "\n10.4 PCA (ренгтгенно-структурный анализ)",
    "text": "10.4 PCA (ренгтгенно-структурный анализ)\n\nСоздание кристалла белка\nОн помещается в аппарат, на него подают рентгеновское излучение\nОно выбивает электроны из атомов и возникает дифракционная картина на подложке\nС помощью обратного преобразования Фурье восстанавливают электронную плотность, а затем строят модель атомов белка\nПостроение атомной модели и уточнение координат",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>БД трехмерных структур</span>"
    ]
  },
  {
    "objectID": "Базы_данных_БД_трехмерных_структур.html#криоэлектронная-микроскопия-cryo-em",
    "href": "Базы_данных_БД_трехмерных_структур.html#криоэлектронная-микроскопия-cryo-em",
    "title": "\n10  БД трехмерных структур\n",
    "section": "\n10.5 Криоэлектронная микроскопия (cryo-EM)",
    "text": "10.5 Криоэлектронная микроскопия (cryo-EM)\n\nЗамораживание образца в витрифицированном льду без кристиаллизации\nСъемка на электронном микроскопе - множество 2D - кадров\nСегментация и классификация частиц\n3D - реконструкция",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>БД трехмерных структур</span>"
    ]
  },
  {
    "objectID": "Базы_данных_БД_трехмерных_структур.html#pbd-база-данных-3d-структур",
    "href": "Базы_данных_БД_трехмерных_структур.html#pbd-база-данных-3d-структур",
    "title": "\n10  БД трехмерных структур\n",
    "section": "\n10.6 PBD: база данных 3D структур",
    "text": "10.6 PBD: база данных 3D структур\nPDB формат содержит всю доступную метаинформацию и координаты каждого атома",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>БД трехмерных структур</span>"
    ]
  },
  {
    "objectID": "Базы_данных_БД_трехмерных_структур.html#pymol",
    "href": "Базы_данных_БД_трехмерных_структур.html#pymol",
    "title": "\n10  БД трехмерных структур\n",
    "section": "\n10.7 PyMol",
    "text": "10.7 PyMol\nПрограмма для визуализации и манипуляции трехмернвми структурами биомолекул (белков, нуклеиновых кислот, комплексов)",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>БД трехмерных структур</span>"
    ]
  },
  {
    "objectID": "Базы_данных_БД_трехмерных_структур.html#alphafold",
    "href": "Базы_данных_БД_трехмерных_структур.html#alphafold",
    "title": "\n10  БД трехмерных структур\n",
    "section": "\n10.8 AlphaFold",
    "text": "10.8 AlphaFold\nНейросетевая модель, предсказывающая пространственную структуру белка по аминокислотной последовательности 1. Вход - ак последовательность белка 2. Поиск гомологий - построение множественного выравнивания (MSA) 3. Нейросеть предсказывает контакты и расстояния между остатками 4. Геометрический модуль реконструирует 3D- модель с атомными координатами 5. Оценка доверия для каждого участка (plDDT score)",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>БД трехмерных структур</span>"
    ]
  },
  {
    "objectID": "Базы_данных_БД_трехмерных_структур.html#молекулярная-динамика",
    "href": "Базы_данных_БД_трехмерных_структур.html#молекулярная-динамика",
    "title": "\n10  БД трехмерных структур\n",
    "section": "\n10.9 Молекулярная динамика",
    "text": "10.9 Молекулярная динамика\n\nСиловое поле\nНачальные условия\nГраничные условия\nШаг интегрирования\nИнтегратор",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>БД трехмерных структур</span>"
    ]
  },
  {
    "objectID": "Базы_данных_БД_трехмерных_структур.html#докинг",
    "href": "Базы_данных_БД_трехмерных_структур.html#докинг",
    "title": "\n10  БД трехмерных структур\n",
    "section": "\n10.10 Докинг",
    "text": "10.10 Докинг\nБолее дешеыый аналог молекулярной динамики. Это компьютерный метод предсказания оптимальной ориентации и энергоэффективности комплекса между макромолекулой и лигандом на основе оценки взаимных взаимодействий.\n\n\nДокинг vs Молекулярная динамика",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>БД трехмерных структур</span>"
    ]
  },
  {
    "objectID": "Базы_данных_БД_трехмерных_структур.html#протеомика",
    "href": "Базы_данных_БД_трехмерных_структур.html#протеомика",
    "title": "\n10  БД трехмерных структур\n",
    "section": "\n10.11 Протеомика",
    "text": "10.11 Протеомика\nИзучение всех белков организма\nМасс-спектрометрия: Белки - пептиды - спектры по массе - БД референсных белков и масс - список белков",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>БД трехмерных структур</span>"
    ]
  },
  {
    "objectID": "Базы_данных_функциональные_БД.html",
    "href": "Базы_данных_функциональные_БД.html",
    "title": "\n11  Фукнциональные БД\n",
    "section": "",
    "text": "11.1 Поиск ОРФ - GENEMARK\nФукнциональные БД",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Фукнциональные БД</span>"
    ]
  },
  {
    "objectID": "Базы_данных_функциональные_БД.html#blast-для-аннотации",
    "href": "Базы_данных_функциональные_БД.html#blast-для-аннотации",
    "title": "\n11  Фукнциональные БД\n",
    "section": "\n11.2 BLAST для аннотации",
    "text": "11.2 BLAST для аннотации\ne-value &lt; \\(10^{-5}\\)\npident &gt;= 70%\nРекомендация - проверять выравнивание",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Фукнциональные БД</span>"
    ]
  },
  {
    "objectID": "Базы_данных_функциональные_БД.html#mmmer-для-аннотации",
    "href": "Базы_данных_функциональные_БД.html#mmmer-для-аннотации",
    "title": "\n11  Фукнциональные БД\n",
    "section": "\n11.3 MMMER для аннотации",
    "text": "11.3 MMMER для аннотации",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Фукнциональные БД</span>"
    ]
  },
  {
    "objectID": "Базы_данных_функциональные_БД.html#базы-данных-генов-и-их-продуктов",
    "href": "Базы_данных_функциональные_БД.html#базы-данных-генов-и-их-продуктов",
    "title": "\n11  Фукнциональные БД\n",
    "section": "\n11.4 Базы данных генов и их продуктов",
    "text": "11.4 Базы данных генов и их продуктов\n\nCOG - группы ортологичных генов\nEggNOG - функциональная аннотация через эволюционные группы\nOrthoDB - ортологические группы и функциональные аннотациии\nGO\nDeepGO - ИИ аннотация\nKEGG\nReactome",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Фукнциональные БД</span>"
    ]
  },
  {
    "objectID": "Базы_данных_функциональные_БД.html#eggnog-v5.0",
    "href": "Базы_данных_функциональные_БД.html#eggnog-v5.0",
    "title": "\n11  Фукнциональные БД\n",
    "section": "\n12.1 EggNOG v5.0\n",
    "text": "12.1 EggNOG v5.0\n\n\n\nThe eggNOG workflow at a glance\n\nЗаходим в sequence search сбоку и сделаем поиск одной белковой последовательности из файла\nЗайдем в один из результатов  и видим 15 белков из 14 видов.\nЧтобы запустить из командной строки надо\n\nconda activate py3_study\nconda install -c conda-forge -c bioconda eggnog-mapper\nmkdir eggnog_data\n\ndownload_eggnog_data.py --data_dir ./eggnog_data- не работает?? (можно скачать базу данных)\nemapper.py -i 26.11.25/protein.fasta -o emapper --cpu 1 --data_dir ./eggnog_data",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Фукнциональные БД</span>"
    ]
  },
  {
    "objectID": "Базы_данных_функциональные_БД.html#kegg",
    "href": "Базы_данных_функциональные_БД.html#kegg",
    "title": "\n11  Фукнциональные БД\n",
    "section": "\n12.2 KEGG\n",
    "text": "12.2 KEGG\n\nОткроем какой-нибудь метаболический путь\nВ вершинах - компаунды (низкомолекулярные в-ва, которые синтезируются)\n\n\nПример пути\n\nЕсть R пакет, который обращается к KEGG, либо использовать онлайн - сервис",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Фукнциональные БД</span>"
    ]
  },
  {
    "objectID": "Базы_данных_функциональные_БД.html#geneontology",
    "href": "Базы_данных_функциональные_БД.html#geneontology",
    "title": "\n11  Фукнциональные БД\n",
    "section": "\n12.3 GeneOntology\n",
    "text": "12.3 GeneOntology",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Фукнциональные БД</span>"
    ]
  },
  {
    "objectID": "Базы_данных_функциональные_БД.html#deepgo",
    "href": "Базы_данных_функциональные_БД.html#deepgo",
    "title": "\n11  Фукнциональные БД\n",
    "section": "\n12.4 DeepGO\n",
    "text": "12.4 DeepGO\n\nПоиск GO-идентификаторов, котоыре описывают заданную последовательность с использованием нейро-сеток\nОнлайн сервис",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Фукнциональные БД</span>"
    ]
  },
  {
    "objectID": "Базы_данных_функциональные_БД.html#string---база-белок-белковых-взаимодействий",
    "href": "Базы_данных_функциональные_БД.html#string---база-белок-белковых-взаимодействий",
    "title": "\n11  Фукнциональные БД\n",
    "section": "\n12.5 String - база белок-белковых взаимодействий",
    "text": "12.5 String - база белок-белковых взаимодействий\nSearch -&gt; Protein by name -&gt; lacZ -&gt; continue\n\n\nString example",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Фукнциональные БД</span>"
    ]
  },
  {
    "objectID": "Базы_данных_филогенетика.html",
    "href": "Базы_данных_филогенетика.html",
    "title": "\n12  Филогенетические деревья\n",
    "section": "",
    "text": "12.1 Типы деревьев\nУкорененные/неукорененные (надо проверять, какое именно дерево строит программа - бывает, что она произвольно вставляет корень); ультраметрические/аддитивные",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Филогенетические деревья</span>"
    ]
  },
  {
    "objectID": "Базы_данных_филогенетика.html#базовые-понятия",
    "href": "Базы_данных_филогенетика.html#базовые-понятия",
    "title": "\n12  Филогенетические деревья\n",
    "section": "\n12.2 Базовые понятия",
    "text": "12.2 Базовые понятия\n\nЛистья\nВнутренние узлы (это зачастую гипотетические предки)\nКорень (гипотетические прародитель всех)\nВетви\nКлады (группы листьев, объединенные внутренним узлом)",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Филогенетические деревья</span>"
    ]
  },
  {
    "objectID": "Базы_данных_филогенетика.html#источники-данных-для-построения-деревьев",
    "href": "Базы_данных_филогенетика.html#источники-данных-для-построения-деревьев",
    "title": "\n12  Филогенетические деревья\n",
    "section": "\n12.3 Источники данных для построения деревьев",
    "text": "12.3 Источники данных для построения деревьев\n\nМножественное выравнивание\nМатрица расстояний\nДерево\n\n\n12.3.1 Множественное выравнивание\n\nПоследовательности должны быть родственными, ортологи\nОчистка (бывают вставки, которые стоит удалить)\n\n12.3.2 Эволюционнные модели: ДНК\n\nJukes-Cantor\n\n\nВсе замены равновероятны\nЧастоты нуклеотидов - тоже равные\nИспоользуется для коротких эволюционных расстояний (например подходит для вирусов)\n\n\nKimura\n\n\nРазличает транзиции и трансверсии\nТранзиции происходят чаще\n\n\n\nТранзиции и трансверсии\n\n\nHasegava-Kishino-Yano\n\n\nДля ML - филогенетики\nКак Кимура + учитываются неравные частоты нуклеотидов\n\n\nGeneral Time Reversible\n\n12.3.3 Эволюционнные модели: Белок\n\nPAM\nBLOSUM\nLG (стандарт в IQ-TREE, PhyLM, RAxML)\nСтроится на огромном наборе белковых MSA\n\n12.3.4 Матрица расстояний\nКаждый элемент - эволюционная дистанция между двумя объектами\n\nНеотрицательность\nСимметричность\n\n\\(d_{ii}\\) = 0\n\n\n12.3.4.1 Методы подсчета\n\np-distance (proportion distance) \\(d_{ij} = \\frac{число~ различий}{общая~ длина ~сравнения}\\)\n\nML - посчитать t, при котором вероятность реализованного исхода наибольшая …\n\n12.3.5 Построение дерева\n\n12.3.5.1 Neighbor-Joining (NJ)\nМетод ближайшего соседа\nВ начальной точке все последовательности равноудалены, алгоритм начинает с пары с минимальным расстоянием, к ней присоединяется следующая по минимальному расстоянию, строится неукорененное дерево (ведь мы начинаем с листьев)\nНе требует равных скоростей эволюции\nТопология дерево сильно зависит от того, откуда мы начнем его строить\n\n12.3.5.2 Maximum Parsimony\nНаиболее вероятным считается дерево, требующее минимального числа эволюционных изменений\nL(T) - длина дерева T = argmin(L(T))\nЕсть несколько алгоритмов подсчета длин деревьев, без полного перебора\nПредполагает одинаковую скорость эволюции\nСтроит неукорененное дерево\n\n12.3.5.3 UPGMA (Unweight Pair Group Method with Arithmetic Mean)\nОдинаковая скорость эволюции + есть корень -&gt; строит укорененное, ультраметрическое дерево\n\n12.3.5.4 Maximum Likelyhood\n\\(T^*,~ \\theta^* = arg~ max L(T,\\theta~|MSA )\\)\nНачальноу дерево -&gt; Оценить длину дерева -&gt; Есть улучшения? -&gt; и тд\n\n12.3.5.5 Сравнение всех методов\n\n\nAlt text",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Филогенетические деревья</span>"
    ]
  },
  {
    "objectID": "Базы_данных_филогенетика.html#форматы-дереьев",
    "href": "Базы_данных_филогенетика.html#форматы-дереьев",
    "title": "\n12  Филогенетические деревья\n",
    "section": "\n12.4 Форматы дереьев",
    "text": "12.4 Форматы дереьев\n\nNewick (bootstrap - проверка дерева на устойчивость - если убрать лист - изменится ли топология клады) ((A:0.1,B:0.2)90:0.3,C:0.4)\nNexus Begin tree; Tree T1 = ((A,B),C); End;\n\nОснован на блоках кода - XML - based (PHYLOXML) - JSON-based (Nextstrain)",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Филогенетические деревья</span>"
    ]
  },
  {
    "objectID": "Базы_данных_филогенетика.html#визуализация",
    "href": "Базы_данных_филогенетика.html#визуализация",
    "title": "\n12  Филогенетические деревья\n",
    "section": "\n12.5 Визуализация",
    "text": "12.5 Визуализация\n\niTOL\nDendroscope\nAuspice (для эпидемиологического анализа)\nMEGA (хороша для обучения)\nUGEN",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Филогенетические деревья</span>"
    ]
  },
  {
    "objectID": "Базы_данных_филогенетика.html#устанваливаем-пакеты-bmge-iqtree-emboss-phylip",
    "href": "Базы_данных_филогенетика.html#устанваливаем-пакеты-bmge-iqtree-emboss-phylip",
    "title": "\n12  Филогенетические деревья\n",
    "section": "\n13.1 Устанваливаем пакеты bmge, iqtree, emboss, phylip",
    "text": "13.1 Устанваливаем пакеты bmge, iqtree, emboss, phylip\n\nconda activate py3_study\nconda install -c bioconda bmge -y\nconda install -c bioconda -c conda-forge iqtree emboss phylip -y",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Филогенетические деревья</span>"
    ]
  },
  {
    "objectID": "Базы_данных_филогенетика.html#строим-множественное-выравнивание",
    "href": "Базы_данных_филогенетика.html#строим-множественное-выравнивание",
    "title": "\n12  Филогенетические деревья\n",
    "section": "\n13.2 Строим множественное выравнивание",
    "text": "13.2 Строим множественное выравнивание\n\nmuscle -align Структуры_данных/03.12.25/seqs.fasta -output Структуры_данных/03.12.25/seqs.aln.fasta\n\n\nmuscle 5.3.osx64 []  8.6Gb RAM, 4 cores\nBuilt Jul 30 2025 21:35:18\n(C) Copyright 2004-2021 Robert C. Edgar.\nhttps://drive5.com\n\n[align Структуры_данных/03.12.25/seqs.fasta]\nInput: 15 seqs, avg length 543, max 548, min 530\n\n00:00 2.4Mb     6.7% Derep 1 uniques, 0 dupes\n00:00 2.4Mb   100.0% Derep 15 uniques, 0 dupes\n00:00 2.4Mb  CPU has 4 cores, running 4 threads\n00:00 2.5Mb    0.95% Calc posteriors\n00:01 66Mb      8.6% Calc posteriors\n00:02 80Mb     35.2% Calc posteriors\n00:03 92Mb     61.9% Calc posteriors\n00:04 93Mb     85.7% Calc posteriors\n00:04 80Mb    100.0% Calc posteriors\n00:04 80Mb      7.1% UPGMA5         \n00:04 80Mb    100.0% UPGMA5\n00:04 80Mb     0.95% Consistency (1/2)\n00:04 72Mb    100.0% Consistency (1/2)\n00:04 72Mb     0.95% Consistency (2/2)\n00:04 72Mb    100.0% Consistency (2/2)\n00:04 40Mb      1.0% Refining         \n00:04 35Mb    100.0% Refining\n\n\nСмотрим в UGENE и видим, что качество не очень высокое\n ## Чистим выравнивание от “плохих” позиций\n\nBMGE -i Структуры_данных/03.12.25/seqs.aln.fasta -t AA -m BLOSUM30 -h 0.5 -of Структуры_данных/03.12.25/seqs.aln.trimmed.fasta\n\n   Amino acid sequence alignment seqs.aln.fasta\n   before : 15 sequences / 557 characters\n 0.00% \n 17.95% \n 35.91% \n 53.86% \n 71.81% \n 89.77% \n\n                                                                                                    \n   after :  15 sequences / 528 characters\n                                          \n   after :  15 sequences / 528 characters\n\n\nИ снова посмотрим в UGENE\n\n\nTrimmed alignment\n\nПрограмма аккуратно вырезала неудачные участки выравнивания",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Филогенетические деревья</span>"
    ]
  },
  {
    "objectID": "Базы_данных_филогенетика.html#подсчет-расстояний-для-nj-и-upgma",
    "href": "Базы_данных_филогенетика.html#подсчет-расстояний-для-nj-и-upgma",
    "title": "\n12  Филогенетические деревья\n",
    "section": "\n13.3 Подсчет расстояний для NJ и UPGMA",
    "text": "13.3 Подсчет расстояний для NJ и UPGMA\n\n13.3.1 FASTA -&gt; PHYLIP + переименовываем\n\nseqret -sequence Структуры_данных/03.12.25/seqs.aln.trimmed.fasta -outseq Структуры_данных/03.12.25/seqs.phy -osformat2 phylip\n\nRead and write (return) sequences\n\n\n\nhead Структуры_данных/03.12.25/seqs.phy\n\n 15 528\nCH60_HELPYAKEIKFSDSA RNLLFEGVRQ LHDAVKVTMG PRGRNVLIQK SYGAPSITKD\nCH602_MYCTAKTIAYDEEA RRGLERGLNA LADAVKVTLG PKGRNVVLEK KWGAPTITND\nCH60_BACCRAKDIKFSEEA RRSMLRGVDT LANAVKVTLG PKGRNVVLEK KFGSPLITND\nCH60_STAACVKQLKFSEDA RQAMLRGVDQ LANAVKVTIG PKGRNVVLDK EFTAPLITND\nCH60_STRPSSKEIKFSSDA RSAMVRGVDI LADTVKVTLG PKGRNVVLEK SFGSPLITND\nCH60_LACLASKDIKFSSDA RTAMMRGIDI LADTVKTTLG PKGRNVVLEK SYGSPLITND\nCH60_BACSUAKEIKFSEEA RRAMLRGVDA LADAVKVTLG PKGRNVVLEK KFGSPLITND\nCH60_LISMCAKDIKFSEDA RRAMLRGVDQ LANAVKVTLG PKGRNVVLEK KFGSPLITND\nCH60_CHLTRAKNIKYNEEA RKKIQKGVKT LAEAVKVTLG PKGRHVVIDK SFGSPQVTKD\n\n\nPHYLIP-программы по умолчанию читают файл “infile”\n\ncp Структуры_данных/03.12.25/seqs.phy Структуры_данных/03.12.25/infile",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Филогенетические деревья</span>"
    ]
  },
  {
    "objectID": "Базы_данных_филогенетика.html#запускаем-protdist-с-настройками-по-умолчанию",
    "href": "Базы_данных_филогенетика.html#запускаем-protdist-с-настройками-по-умолчанию",
    "title": "\n12  Филогенетические деревья\n",
    "section": "\n13.4 Запускаем protdist с настройками по умолчанию",
    "text": "13.4 Запускаем protdist с настройками по умолчанию\n\ncd Структуры_данных/03.12.25\nprotdist &lt;&lt; EOF\nY\n\ncd -\n\n[2J[H\n[2J[H\nProtein distance algorithm, version 3.697\n\nSettings for this run:\n  P  Use JTT, PMB, PAM, Kimura, categories model?  Jones-Taylor-Thornton matrix\n  G  Gamma distribution of rates among positions?  No\n  C           One category of substitution rates?  Yes\n  W                    Use weights for positions?  No\n  M                   Analyze multiple data sets?  No\n  I                  Input sequences interleaved?  Yes\n  0                 Terminal type (IBM PC, ANSI)?  ANSI\n  1            Print out the data at start of run  No\n  2          Print indications of progress of run  Yes\n\nAre these settings correct? (type Y or the letter for one to change)\n\nComputing distances:\n  CH60_HELPY   \n  CH602_MYCT   .\n  CH60_BACCR   ..\n  CH60_STAAC   ...\n  CH60_STRPS   ....\n  CH60_LACLA   .....\n  CH60_BACSU   ......\n  CH60_LISMC   .......\n  CH60_CHLTR   ........\n  CH60_HAEI8   .........\n  CH60_YERPE   ..........\n  CH60_PSEAE   ...........\n  CH60_KLEP3   ............\n  CH60_ECOLI   .............\n  CH601_VIBC   ..............\n\nOutput written to file \"outfile\"\n\nDone.",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Филогенетические деревья</span>"
    ]
  },
  {
    "objectID": "Базы_данных_филогенетика.html#сохраняем-матрицу-расстояний-в-отдельный-файл",
    "href": "Базы_данных_филогенетика.html#сохраняем-матрицу-расстояний-в-отдельный-файл",
    "title": "\n12  Филогенетические деревья\n",
    "section": "\n13.5 Сохраняем матрицу расстояний в отдельный файл",
    "text": "13.5 Сохраняем матрицу расстояний в отдельный файл\n\nmv Структуры_данных/03.12.25/outfile Структуры_данных/03.12.25/seqs.protdist",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Филогенетические деревья</span>"
    ]
  },
  {
    "objectID": "Базы_данных_филогенетика.html#nj",
    "href": "Базы_данных_филогенетика.html#nj",
    "title": "\n12  Филогенетические деревья\n",
    "section": "\n13.6 NJ",
    "text": "13.6 NJ\nИсходные данные для neighbor должны называться infile\n\ncp Структуры_данных/03.12.25/seqs.protdist Структуры_данных/03.12.25/infile\n\n\ncd Структуры_данных/03.12.25\nneighbor &lt;&lt; EOF\nY\nEOF\ncd -\n\n[2J[H\n[2J[H\nNeighbor-Joining/UPGMA method version 3.697\n\nSettings for this run:\n  N       Neighbor-joining or UPGMA tree?  Neighbor-joining\n  O                        Outgroup root?  No, use as outgroup species  1\n  L         Lower-triangular data matrix?  No\n  R         Upper-triangular data matrix?  No\n  S                        Subreplicates?  No\n  J     Randomize input order of species?  No. Use input order\n  M           Analyze multiple data sets?  No\n  0   Terminal type (IBM PC, ANSI, none)?  ANSI\n  1    Print out the data at start of run  No\n  2  Print indications of progress of run  Yes\n  3                        Print out tree  Yes\n  4       Write out trees onto tree file?  Yes\n\n\n  Y to accept these or type the letter for one to change\n\nCycle  12: species 5 (   0.07431) joins species 6 (   0.10047)\nCycle  11: species 3 (   0.04841) joins species 7 (   0.06128)\nCycle  10: node 3 (   0.01101) joins species 8 (   0.06874)\nCycle   9: node 3 (   0.03094) joins species 4 (   0.17307)\nCycle   8: node 3 (   0.02608) joins node 5 (   0.07966)\nCycle   7: species 2 (   0.28475) joins node 3 (   0.08306)\nCycle   6: node 2 (   0.04067) joins species 9 (   0.27342)\nCycle   5: species 1 (   0.27015) joins node 2 (   0.00408)\nCycle   4: node 1 (   0.10595) joins species 12 (   0.10272)\nCycle   3: node 1 (   0.02055) joins species 15 (   0.19322)\nCycle   2: species 13 (   0.01787) joins species 14 (   0.01368)\nCycle   1: node 1 (   0.03829) joins species 10 (   0.06501)\nlast cycle:\n node 1  (   0.01907) joins species 11  (   0.04739) joins node 13  (   0.02377)\n\nOutput written on file \"outfile\"\n\nTree written on file \"outtree\"\n\nDone.\n\n/Users/lidaflorenskaya/Documents/АлгБио/1_sem/1_sem_algbio_book\n\n\n\nmv Структуры_данных/03.12.25/outtree Структуры_данных/03.12.25/seqs.NJ.tree\nmv Структуры_данных/03.12.25/outfile Структуры_данных/03.12.25/seqs.NJ.log\n\nДерево в Newick-формате:\n\nhead Структуры_данных/03.12.25/seqs.NJ.tree\n\n(((CH602_MYCT:0.28475,((((CH60_BACCR:0.04841,CH60_BACSU:0.06128):0.01101,\nCH60_LISMC:0.06874):0.03094,CH60_STAAC:0.17307):0.02608,\n(CH60_STRPS:0.07431,CH60_LACLA:0.10047):0.07966):0.08306):0.04067,\nCH60_CHLTR:0.27342):0.00408,(CH60_PSEAE:0.10272,(CH601_VIBC:0.19322,\n(CH60_HAEI8:0.06501,(CH60_YERPE:0.04739,(CH60_KLEP3:0.01787,\nCH60_ECOLI:0.01368):0.02377):0.01907):0.03829):0.02055):0.10595,CH60_HELPY:0.27015);\n\n\nФайл с простой визуализацией\n\nhead -50 Структуры_данных/03.12.25/seqs.NJ.log\n\n\n  15 Populations\n\nNeighbor-Joining/UPGMA method version 3.697\n\n\n Neighbor-joining method\n\n Negative branch lengths allowed\n\n       +----------------CH602_MYCT\n       ! \n       !          +--CH60_BACCR\n       !        +-2 \n    +--6      +-3 +--CH60_BACSU\n    !  !      ! ! \n    !  !    +-4 +---CH60_LISMC\n    !  !    ! ! \n    !  +----5 +----------CH60_STAAC\n  +-7       ! \n  ! !       !   +----CH60_STRPS\n  ! !       +---1 \n  ! !           +-----CH60_LACLA\n  ! ! \n  ! +----------------CH60_CHLTR\n  ! \n  !     +------CH60_PSEAE\n  8-----9 \n  !     !  +----------CH601_VIBC\n  !     +-10  \n  !        !  +---CH60_HAEI8\n  !        +-12  \n  !           !  +--CH60_YERPE\n  !           +-13  \n  !              !  +-CH60_KLEP3\n  !              +-11  \n  !                 +CH60_ECOLI\n  ! \n  +---------------CH60_HELPY\n\n\nremember: this is an unrooted tree!\n\nBetween        And            Length\n-------        ---            ------\n   8             7            0.00408\n   7             6            0.04067\n   6          CH602_MYCT      0.28475\n   6             5            0.08306\n\n\nremember: this is an unrooted tree!",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Филогенетические деревья</span>"
    ]
  },
  {
    "objectID": "Базы_данных_филогенетика.html#upgma",
    "href": "Базы_данных_филогенетика.html#upgma",
    "title": "\n12  Филогенетические деревья\n",
    "section": "\n13.7 UPGMA",
    "text": "13.7 UPGMA\n\ncd Структуры_данных/03.12.25\nneighbor &lt;&lt; EOF\nN\nY\nEOF\ncd -\n\n[2J[H\n[2J[H\nNeighbor-Joining/UPGMA method version 3.697\n\nSettings for this run:\n  N       Neighbor-joining or UPGMA tree?  Neighbor-joining\n  O                        Outgroup root?  No, use as outgroup species  1\n  L         Lower-triangular data matrix?  No\n  R         Upper-triangular data matrix?  No\n  S                        Subreplicates?  No\n  J     Randomize input order of species?  No. Use input order\n  M           Analyze multiple data sets?  No\n  0   Terminal type (IBM PC, ANSI, none)?  ANSI\n  1    Print out the data at start of run  No\n  2  Print indications of progress of run  Yes\n  3                        Print out tree  Yes\n  4       Write out trees onto tree file?  Yes\n\n\n  Y to accept these or type the letter for one to change\n[2J[H\nNeighbor-Joining/UPGMA method version 3.697\n\nSettings for this run:\n  N       Neighbor-joining or UPGMA tree?  UPGMA\n  L         Lower-triangular data matrix?  No\n  R         Upper-triangular data matrix?  No\n  S                        Subreplicates?  No\n  J     Randomize input order of species?  No. Use input order\n  M           Analyze multiple data sets?  No\n  0   Terminal type (IBM PC, ANSI, none)?  ANSI\n  1    Print out the data at start of run  No\n  2  Print indications of progress of run  Yes\n  3                        Print out tree  Yes\n  4       Write out trees onto tree file?  Yes\n\n\n  Y to accept these or type the letter for one to change\n\nCycle  14: species 13 (   0.01578) joins species 14 (   0.01578)\nCycle  13: species 11 (   0.04347) joins node 13 (   0.02770)\nCycle  12: species 3 (   0.05484) joins species 7 (   0.05484)\nCycle  11: species 10 (   0.06301) joins node 11 (   0.01954)\nCycle  10: node 3 (   0.01245) joins species 8 (   0.06730)\nCycle   9: species 5 (   0.08739) joins species 6 (   0.08739)\nCycle   8: node 10 (   0.04638) joins species 12 (   0.10939)\nCycle   7: node 3 (   0.06915) joins species 4 (   0.13645)\nCycle   6: node 10 (   0.04185) joins species 15 (   0.15124)\nCycle   5: node 3 (   0.02019) joins node 5 (   0.06925)\nCycle   4: species 1 (   0.25482) joins node 10 (   0.10358)\nCycle   3: species 2 (   0.25603) joins node 3 (   0.09939)\nCycle   2: node 1 (   0.00586) joins species 9 (   0.26068)\nCycle   1: node 1 (   0.00595) joins node 2 (   0.01060)\n\nOutput written on file \"outfile\"\n\nTree written on file \"outtree\"\n\nDone.\n\n/Users/lidaflorenskaya/Documents/АлгБио/1_sem/1_sem_algbio_book\n\n\n\nmv Структуры_данных/03.12.25/outtree Структуры_данных/03.12.25/seqs.UPGMA.tree\nmv Структуры_данных/03.12.25/outfile Структуры_данных/03.12.25/seqs.UPGMA.log\n\n\nhead -50 Структуры_данных/03.12.25/seqs.UPGMA.log\n\n\n  15 Populations\n\nNeighbor-Joining/UPGMA method version 3.697\n\n\n UPGMA method\n\n Negative branch lengths allowed\n\n        +--------------CH60_HELPY\n        !  \n        !          +---CH60_HAEI8\n        !       +--4 \n     +-11       !  ! +--CH60_YERPE\n     !  !       !  +-2 \n     !  !     +-7    ! +CH60_KLEP3\n     !  !     ! !    +-1 \n     !  !     ! !      +CH60_ECOLI\n  +-13  +-----9 ! \n  !  !        ! +------CH60_PSEAE\n  !  !        ! \n  !  !        +--------CH601_VIBC\n  !  !  \n-14  +---------------CH60_CHLTR\n  !  \n  !  +--------------CH602_MYCT\n  !  !  \n  !  !             +--CH60_BACCR\n  !  !           +-3 \n  +-12       +---5 +--CH60_BACSU\n     !       !   ! \n     !     +-8   +---CH60_LISMC\n     !     ! ! \n     +----10 +-------CH60_STAAC\n           !  \n           !   +----CH60_STRPS\n           +---6 \n               +----CH60_LACLA\n\n\nFrom     To            Length          Height\n----     --            ------          ------\n  14       13          0.00595         0.00595\n  13       11          0.00586         0.01181\n  11     CH60_HELPY    0.25482         0.26663\n  11        9          0.10358         0.11538\n   9        7          0.04185         0.15724\n   7        4          0.04638         0.20362\n\n\nМожем сравнить деревья в Sublime Text\n\n\nComparison\n\n\nhead Структуры_данных/03.12.25/seqs.UPGMA.tree\n\n(((CH60_HELPY:0.25482,(((CH60_HAEI8:0.06301,(CH60_YERPE:0.04347,\n(CH60_KLEP3:0.01578,CH60_ECOLI:0.01578):0.02770):0.01954):0.04638,\nCH60_PSEAE:0.10939):0.04185,CH601_VIBC:0.15124):0.10358):0.00586,\nCH60_CHLTR:0.26068):0.00595,(CH602_MYCT:0.25603,((((CH60_BACCR:0.05484,\nCH60_BACSU:0.05484):0.01245,CH60_LISMC:0.06730):0.06915,\nCH60_STAAC:0.13645):0.02019,(CH60_STRPS:0.08739,CH60_LACLA:0.08739):0.06925):0.09939):0.01060);",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Филогенетические деревья</span>"
    ]
  },
  {
    "objectID": "Базы_данных_филогенетика.html#ml",
    "href": "Базы_данных_филогенетика.html#ml",
    "title": "\n12  Филогенетические деревья\n",
    "section": "\n13.8 ML",
    "text": "13.8 ML\n\niqtree -s Структуры_данных/03.12.25/seqs.aln.trimmed.fasta --seqtype AA -m MFP -bb 1000 -nt AUTO\n\nNEWICK\n\nhead Структуры_данных/03.12.25/seqs.aln.trimmed.fasta.treefile\n\n(CH60_HELPY:0.3898588752,(CH602_MYCTU:0.3912167735,(((CH60_BACCR:0.0803259504,CH60_BACSU:0.0493609255)68:0.0280073589,CH60_LISMC:0.0756762233)58:0.0341075748,(CH60_STAAC:0.2126168178,(CH60_STRPS:0.0734405241,CH60_LACLA:0.1349756976)100:0.1553805108)82:0.0348490400)100:0.1682327665)99:0.1208257866,(CH60_CHLTR:0.4156398474,(((CH60_HAEI8:0.0772703352,(CH60_YERPE:0.0525477043,(CH60_KLEP3:0.0269603591,CH60_ECOLI:0.0083411322)86:0.0344113677)83:0.0362044668)91:0.0439997970,CH601_VIBC3:0.2702593075)92:0.0538020845,CH60_PSEAE:0.1392840272)100:0.1665632925)41:0.0224134680);\n\n\nNEXUS\n\nhead -50 Структуры_данных/03.12.25/seqs.aln.trimmed.fasta.splits.nex\n\n#nexus\n\nBEGIN Taxa;\nDIMENSIONS ntax=15;\nTAXLABELS\n[1] 'CH60_HELPY'\n[2] 'CH602_MYCTU'\n[3] 'CH60_BACCR'\n[4] 'CH60_STAAC'\n[5] 'CH60_STRPS'\n[6] 'CH60_LACLA'\n[7] 'CH60_BACSU'\n[8] 'CH60_LISMC'\n[9] 'CH60_CHLTR'\n[10] 'CH60_HAEI8'\n[11] 'CH60_YERPE'\n[12] 'CH60_PSEAE'\n[13] 'CH60_KLEP3'\n[14] 'CH60_ECOLI'\n[15] 'CH601_VIBC3'\n;\nEND; [Taxa]\n\nBEGIN Splits;\nDIMENSIONS ntax=15 nsplits=63;\nFORMAT labels=no weights=yes confidences=no intervals=no;\nMATRIX\n    100  2,\n    100  3,\n    100  7,\n    68   3 7,\n    100  8,\n    58   3 7 8,\n    100  4,\n    100  5,\n    100  6,\n    100  5 6,\n    82   4 5 6,\n    100  3 4 5 6 7 8,\n    99   2 3 4 5 6 7 8,\n    100  10,\n    100  11,\n    12   10 11,\n    100  13,\n    100  14,\n    86   13 14,\n    91   10 11 13 14,\n    100  15,\n    92   10 11 13 14 15,\n    100  12,\n\n\nЛучшее и консенсуснное дерево:\n\ntail -150 Структуры_данных/03.12.25/seqs.aln.trimmed.fasta.iqtree\n\nMTVER+G4          -8099.182   16254.365 - 5.42e-294   16257.619 - 7.71e-294   16373.900 - 3.39e-293\nMTVER+I+G4        -8099.449   16256.898 - 1.53e-294   16260.392 - 1.93e-294   16380.701 - 1.13e-294\nHIVW+G4           -8123.422   16302.844 - 1.61e-304   16306.099 - 2.29e-304   16422.379 - 1.01e-303\nHIVW+I+G4         -8121.712   16301.425 - 3.27e-304   16304.919 - 4.13e-304   16425.228 - 2.43e-304\nMTMAM+G4          -8194.676   16445.351 -        0   16448.606 -        0   16564.886 -        0\nMTMAM+I+G4        -8195.056   16448.113 -        0   16451.607 -        0   16571.917 -        0\n\nAIC, w-AIC   : Akaike information criterion scores and weights.\nAICc, w-AICc : Corrected AIC scores and weights.\nBIC, w-BIC   : Bayesian information criterion scores and weights.\n\nPlus signs denote the 95% confidence sets.\nMinus signs denote significant exclusion.\n\nSUBSTITUTION PROCESS\n--------------------\n\nModel of substitution: LG+G4\n\nState frequencies: (model)\n\nModel of rate heterogeneity: Gamma with 4 categories\nGamma shape alpha: 0.7552\n\n Category  Relative_rate  Proportion\n  1         0.0860         0.2500\n  2         0.3884         0.2500\n  3         0.9437         0.2500\n  4         2.5819         0.2500\nRelative rates are computed as MEAN of the portion of the Gamma distribution falling in the category.\n\nMAXIMUM LIKELIHOOD TREE\n-----------------------\n\nLog-likelihood of the tree: -7425.8244 (s.e. 223.0207)\nUnconstrained log-likelihood (without tree): -2897.0082\nNumber of free parameters (#branches + #model parameters): 28\nAkaike information criterion (AIC) score: 14907.6488\nCorrected Akaike information criterion (AICc) score: 14910.9033\nBayesian information criterion (BIC) score: 15027.1835\n\nTotal tree length (sum of branch lengths): 3.2966\nSum of internal branch lengths: 0.8988 (27.2646% of tree length)\n\nNOTE: Tree is UNROOTED although outgroup taxon 'CH60_HELPY' is drawn at root\nNumbers in parentheses are  ultrafast bootstrap support (%)\n\n+-------------------------------------CH60_HELPY\n|\n|          +-------------------------------------CH602_MYCTU\n+----------| (99)\n|          |                     +------CH60_BACCR\n|          |                  +--| (68)\n|          |                  |  +---CH60_BACSU\n|          |               +--| (58)\n|          |               |  +------CH60_LISMC\n|          +---------------| (100)\n|                          |  +-------------------CH60_STAAC\n|                          +--| (82)\n|                             |              +------CH60_STRPS\n|                             +--------------| (100)\n|                                            +------------CH60_LACLA\n|\n|  +---------------------------------------CH60_CHLTR\n+--| (41)\n   |                        +------CH60_HAEI8\n   |                    +---| (91)\n   |                    |   |  +----CH60_YERPE\n   |                    |   +--| (83)\n   |                    |      |  +--CH60_KLEP3\n   |                    |      +--| (86)\n   |                    |         +--CH60_ECOLI\n   |               +----| (92)\n   |               |    +-------------------------CH601_VIBC3\n   +---------------| (100)\n                   +------------CH60_PSEAE\n\nTree in newick format:\n\n(CH60_HELPY:0.3898588752,(CH602_MYCTU:0.3912167735,(((CH60_BACCR:0.0803259504,CH60_BACSU:0.0493609255)68:0.0280073589,CH60_LISMC:0.0756762233)58:0.0341075748,(CH60_STAAC:0.2126168178,(CH60_STRPS:0.0734405241,CH60_LACLA:0.1349756976)100:0.1553805108)82:0.0348490400)100:0.1682327665)99:0.1208257866,(CH60_CHLTR:0.4156398474,(((CH60_HAEI8:0.0772703352,(CH60_YERPE:0.0525477043,(CH60_KLEP3:0.0269603591,CH60_ECOLI:0.0083411322)86:0.0344113677)83:0.0362044668)91:0.0439997970,CH601_VIBC3:0.2702593075)92:0.0538020845,CH60_PSEAE:0.1392840272)100:0.1665632925)41:0.0224134680);\n\nCONSENSUS TREE\n--------------\n\nConsensus tree is constructed from 1000 bootstrap trees\nLog-likelihood of consensus tree: -7425.824432\nRobinson-Foulds distance between ML tree and consensus tree: 0\n\nBranches with support &gt;0.000000% are kept (extended consensus)\nBranch lengths are optimized by maximum likelihood on original alignment\nNumbers in parentheses are bootstrap supports (%)\n\n+-------------------------------------CH60_HELPY\n|\n|          +-------------------------------------CH602_MYCTU\n+----------| (99)\n|          |                     +------CH60_BACCR\n|          |                  +--| (68)\n|          |                  |  +---CH60_BACSU\n|          |               +--| (58)\n|          |               |  +------CH60_LISMC\n|          +---------------| (100)\n|                          |  +-------------------CH60_STAAC\n|                          +--| (82)\n|                             |              +------CH60_STRPS\n|                             +--------------| (100)\n|                                            +------------CH60_LACLA\n|\n|  +---------------------------------------CH60_CHLTR\n+--| (41)\n   |                        +------CH60_HAEI8\n   |                    +---| (91)\n   |                    |   |  +----CH60_YERPE\n   |                    |   +--| (83)\n   |                    |      |  +--CH60_KLEP3\n   |                    |      +--| (86)\n   |                    |         +--CH60_ECOLI\n   |               +----| (92)\n   |               |    +-------------------------CH601_VIBC3\n   +---------------| (100)\n                   +------------CH60_PSEAE\n\n\nConsensus tree in newick format: \n\n(CH60_HELPY:0.3900429813,(CH602_MYCTU:0.3913628883,(((CH60_BACCR:0.0803449626,CH60_BACSU:0.0493723422)68:0.0280140029,CH60_LISMC:0.0756906607)58:0.0341163749,(CH60_STAAC:0.2126878772,(CH60_STRPS:0.0734430703,CH60_LACLA:0.1350221404)100:0.1554341766)82:0.0348420396)100:0.1682942628)99:0.1208632629,(CH60_CHLTR:0.4158742269,(((CH60_HAEI8:0.0773304222,(CH60_YERPE:0.0525875244,(CH60_KLEP3:0.0269855533,CH60_ECOLI:0.0083337849)86:0.0344200356)83:0.0362120560)91:0.0440012661,CH601_VIBC3:0.2704394219)92:0.0537962760,CH60_PSEAE:0.1393833227)100:0.1666421487)41:0.0224015782);\n\nALISIM COMMAND\n--------------\nTo simulate an alignment of the same length as the original alignment, using the tree and model parameters estimated from this analysis, you can use the following command:\n\n--alisim simulated_MSA -t 03.12.25/seqs.aln.trimmed.fasta.treefile -m \"LG+G4{0.755158}\" --length 528\n\nTo mimic the alignment used to produce this analysis, i.e. simulate an alignment of the same length as the original alignment, using the tree and model parameters estimated from this analysis *and* copying the same gap positions as the original alignment, you can use the following command:\n\niqtree -s 03.12.25/seqs.aln.trimmed.fasta --alisim mimicked_MSA\n\nTo simulate any number of alignments in either of the two commandlines above, use the --num-alignments options, for example mimic 100 alignments you would use the command line:\n\niqtree -s 03.12.25/seqs.aln.trimmed.fasta --alisim mimicked_MSA --num-alignments 100\n\nFor more information on using AliSim, please visit: www.iqtree.org/doc/AliSim\n\nTIME STAMP\n----------\n\nDate and time: Wed Dec  3 11:09:13 2025\nTotal CPU time used: 56.419625 seconds (0h:0m:56s)\nTotal wall-clock time used: 63.62741709 seconds (0h:1m:3s)\n\n\nПоявились bootstrepы\nconda deactivate",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Филогенетические деревья</span>"
    ]
  },
  {
    "objectID": "Базы_данных_филогенетика.html#визуализация-на-сайте-itools",
    "href": "Базы_данных_филогенетика.html#визуализация-на-сайте-itools",
    "title": "\n12  Филогенетические деревья\n",
    "section": "\n13.9 Визуализация на сайте Itools",
    "text": "13.9 Визуализация на сайте Itools\nМожем добавить метаданные - нужно создать новый датасет и вручную вставить данные из файла с метаданными, например\n0 - не патоген, 1 - патоген.\n\nhead Структуры_данных/03.12.25/path.txt\n\nCH60_ECOLI  0\nCH60_PSEAE  1\nCH601_VIBC  1\nCH60_YERPE  1\nCH60_KLEP3  1\nCH60_HAEI8  1\nCH60_CHLTR  1\nCH60_BACSU  0\nCH60_BACCR  1\nCH60_LISMC  1\n\n\n\n\nDataset in Itools\n\n\n\nResult",
    "crumbs": [
      "Базы данных",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Филогенетические деревья</span>"
    ]
  },
  {
    "objectID": "Алгоритмы_HW.html",
    "href": "Алгоритмы_HW.html",
    "title": "13  Алгоритмы и струкутры данных",
    "section": "",
    "text": "13.1 Задача 1. Сделать реверс односвязного списка.\nВыполнение домашнего задания\nПример: Входные данные: 1, 2, 3, 4, 5. Результат: 5, 4, 3, 2, 1\nclass Node():\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n        \nclass linked_list():\n    def __init__(self):\n        self.header = None\n\n    def append_node(self, data):\n        if self.header :\n            cur_node = self.header\n            while cur_node.next:\n                cur_node = cur_node.next\n            cur_node.next = Node(data)\n        else:\n            self.header = Node(data)\n    \n    def print_list(self):\n        curr = self.header\n        print('start', end=\" -&gt; \")\n        while curr:\n            print(curr.data, end=\" -&gt; \")\n            curr = curr.next\n        print('end')\n# затраты по памяти - константа O(1)\n# оценка сложности - O(n)\n    def reverse_list(self):\n        prev = None\n        curr = self.header\n        while curr and curr.next:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        self.header = curr\n        self.header.next = prev\na = linked_list()\na.append_node(5)\na.append_node(55)\na.append_node(355)\na.print_list()\na.reverse_list()\na.print_list()\n\nstart -&gt; 5 -&gt; 55 -&gt; 355 -&gt; end\nstart -&gt; 355 -&gt; 55 -&gt; 5 -&gt; end",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Алгоритмы и струкутры данных</span>"
    ]
  },
  {
    "objectID": "Алгоритмы_HW.html#задача-2.-сортировка-документов.",
    "href": "Алгоритмы_HW.html#задача-2.-сортировка-документов.",
    "title": "13  Алгоритмы и струкутры данных",
    "section": "13.2 Задача 2. Сортировка документов.",
    "text": "13.2 Задача 2. Сортировка документов.\nПамять - O(d × n) - хранение признаков всех документов\nПервоначальная сортировка: O(d log d) Вычисление релевантностей: O(d × n)\nЗапрос типа 1 (получить топ-k): O(k) Запрос типа 2 (изменить признак): O(log d) - бинарный поиск, удаление из списка: O(d) - в худшем случае -&gt; O(d) в худшем случае\n\ndef binary_search_left(arr, x):\n    \"\"\"\n    Бинарный поиск для нахождения позиции вставки\n    \"\"\"\n    left, right = 0, len(arr)\n    while left &lt; right:\n        mid = (left + right) // 2\n        if arr[mid] &lt; x:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\ndef solve_ranking_problem(input_data):\n    \"\"\"\n    Решает задачу ранжирования с входными данными в виде строки\n    \"\"\"\n    lines = input_data.strip().split('\\n')\n    idx = 0\n    \n    # Чтение количества параметров\n    n = int(lines[idx]); idx += 1\n    \n    # Чтение параметров формулы\n    a = list(map(int, lines[idx].split())); idx += 1\n    \n    # Чтение количества объектов\n    d = int(lines[idx]); idx += 1\n    \n    # Структуры для хранения данных\n    docs = []  # список кортежей (-релевантность, id)\n    features = {}\n    relevances = {}\n    \n    # Чтение объектов\n    for doc_id in range(1, d + 1):\n        doc_features = list(map(int, lines[idx].split()))\n        idx += 1\n        \n        # Вычисление релевантности\n        relevance = sum(a[i] * doc_features[i] for i in range(n))\n        \n        features[doc_id] = doc_features\n        relevances[doc_id] = relevance\n        docs.append((-relevance, doc_id))\n    \n    # Сортируем документы по убыванию релевантности\n    docs.sort()\n    \n    # Чтение количества запросов\n    q = int(lines[idx]); idx += 1\n    \n    results = []\n    \n    # Обработка запросов\n    for _ in range(q):\n        query_parts = lines[idx].split()\n        idx += 1\n        \n        query_type = int(query_parts[0])\n        \n        if query_type == 1:\n            # Запрос на получение k самых релевантных\n            k = int(query_parts[1])\n            top_k = [str(doc_id) for _, doc_id in docs[:k]]\n            results.append(\" \".join(top_k))\n            \n        else:\n            # Запрос на изменение признака: 2 doc_id feature_index new_value\n            doc_id = int(query_parts[1])\n            feature_idx = int(query_parts[2]) - 1  # переводим в 0-based индекс\n            new_value = int(query_parts[3])\n            \n            # Удаляем старую версию документа из списка\n            old_relevance = relevances[doc_id]\n            target = (-old_relevance, doc_id)\n            \n            # Ищем позицию для удаления\n            pos = binary_search_left(docs, target)\n            if pos &lt; len(docs) and docs[pos] == target:\n                docs.pop(pos)\n            \n            # Обновляем признак\n            old_feature_value = features[doc_id][feature_idx]\n            features[doc_id][feature_idx] = new_value\n            \n            # Пересчитываем релевантность\n            delta = a[feature_idx] * (new_value - old_feature_value)\n            new_relevance = old_relevance + delta\n            relevances[doc_id] = new_relevance\n            \n            # Вставляем обновленный документ на правильную позицию\n            new_entry = (-new_relevance, doc_id)\n            insert_pos = binary_search_left(docs, new_entry)\n            docs.insert(insert_pos, new_entry)\n    \n    return results\n\n# Пример использования с тестовыми данными\nif __name__ == \"__main__\":\n    # Входные данные как строка\n    input_str = \"\"\"2\n1 100\n10\n1 2\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1\n9 1\n10 1\n4\n1 2\n1 10\n2 4 1 1000\n1 10\"\"\"\n    \n    # Решаем задачу\n    output = solve_ranking_problem(input_str)\n    \n    # Выводим результаты\n    for line in output:\n        print(line)\n\n1 10\n1 10 9 8 7 6 5 4 3 2\n4 1 10 9 8 7 6 5 3 2",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Алгоритмы и струкутры данных</span>"
    ]
  },
  {
    "objectID": "Алгоритмы_HW.html#задача-3.-реализовать-балансировку-красно-черного-дерева.",
    "href": "Алгоритмы_HW.html#задача-3.-реализовать-балансировку-красно-черного-дерева.",
    "title": "13  Алгоритмы и струкутры данных",
    "section": "13.3 Задача 3. Реализовать балансировку красно-черного дерева.",
    "text": "13.3 Задача 3. Реализовать балансировку красно-черного дерева.\nБинарное дерево поиска является красно-черным деревом, если оно удовлетворяет следующим красно-черным свойствам. 1. Каждый узел является красным или черным. 2. Корень дерева является черным. 3. Каждый лист дерева (NIL) является черным. 4. Если узел - красный, то оба его дочерних узла - черные. 5. Для каждого узла все пути от него до листьев, являющихся потомками данного узла, содержат одно и то же количество черных узлов.\nРазбор балансировки с habr\n  \n\nclass Node():\n    def __init__(self, data):\n        self.data = data\n        self.right = None\n        self.left = None\n        self.parent = None\n        self.color = \"RED\"\n\nclass Tree():\n    def __init__(self):\n        self.root = None\n    \n    def insert(self, data):\n        print(f\"\\nВставляем {data}\")\n        \n        new_node = Node(data)\n        if not self.root:\n            self.root = new_node\n            self.root.color = \"BLACK\"\n            print(\"После вставки:\")\n            self.print()\n            return\n        \n        current, parent = self.root, None\n        while current:\n            parent = current\n            if data &lt; current.data:\n                current = current.left\n            else:\n                current = current.right\n        \n        new_node.parent = parent\n        if data &lt; parent.data:\n            parent.left = new_node\n        else:\n            parent.right = new_node\n        \n        print(\"После вставки до балансировки:\")\n        self.print()\n        \n        self.balance_insert(new_node)\n        \n        print(\"После балансировки:\")\n        self.print()\n    \n    def balance_insert(self, node):\n        while node != self.root and node.parent.color == \"RED\":\n            parent, grandparent = node.parent, node.parent.parent\n            \n            if parent == grandparent.left:\n                uncle = grandparent.right\n                if uncle and uncle.color == \"RED\":\n                    print(\"Case 1: дядя красный\")\n                    self.case_1(parent, uncle, grandparent)\n                    node = grandparent\n                else:\n                    if node == parent.right:\n                        print(\"Case 2: узел справа\")\n                        node = parent\n                        self.small_rotation(node, 0)\n                    print(\"Case 3: большой поворот\")\n                    self.case_3(parent, grandparent)\n                    break\n            else:\n                uncle = grandparent.left\n                if uncle and uncle.color == \"RED\":\n                    print(\"Case 1: дядя красный\")\n                    self.case_1(parent, uncle, grandparent)\n                    node = grandparent\n                else:\n                    if node == parent.left:\n                        print(\"Case 2: узел слева\")\n                        node = parent\n                        self.small_rotation(node, 1)\n                    print(\"Case 3: большой поворот\")\n                    self.case_3(parent, grandparent)\n                    break\n        \n        self.root.color = \"BLACK\"\n    \n    def case_1(self, parent, uncle, grandparent):\n        parent.color = uncle.color = \"BLACK\"\n        if grandparent != self.root:\n            grandparent.color = \"RED\"\n    \n    def case_3(self, parent, grandparent):\n        parent.color = \"BLACK\"\n        grandparent.color = \"RED\"\n        if parent == grandparent.left:\n            self.big_rotation(grandparent, 1)\n        else:\n            self.big_rotation(grandparent, 0)\n\n    def small_rotation(self, node, direction):\n        if direction == 1:\n            print(f\"Малый правый поворот вокруг {node.data}\")\n            new_root = node.left\n            node.left = new_root.right\n            if new_root.right: \n                new_root.right.parent = node\n            new_root.right = node\n        else:\n            print(f\"Малый левый поворот вокруг {node.data}\")\n            new_root = node.right\n            node.right = new_root.left\n            if new_root.left: \n                new_root.left.parent = node\n            new_root.left = node\n        \n        new_root.parent = node.parent\n        node.parent = new_root\n        \n        if not new_root.parent:\n            self.root = new_root\n        elif new_root.parent.left == node:\n            new_root.parent.left = new_root\n        else:\n            new_root.parent.right = new_root\n        \n        return new_root\n\n    def big_rotation(self, node, direction):\n        if direction == 1:\n            print(f\"Большой правый поворот вокруг {node.data}\")\n            # Левый-правый: сначала левый поворот для левого ребенка, потом правый для узла\n            if node.left and node.left.right:\n                self.small_rotation(node.left, 0)\n            return self.small_rotation(node, 1)\n        else:\n            print(f\"Большой левый поворот вокруг {node.data}\")\n            # Правый-левый: сначала правый поворот для правого ребенка, потом левый для узла\n            if node.right and node.right.left:\n                self.small_rotation(node.right, 1)\n            return self.small_rotation(node, 0)\n\n    def print(self):\n        if not self.root:\n            print(\"Пусто\")\n            return\n        self.print_(self.root)\n        print()\n\n    def print_(self, node):\n        if node:\n            color = \"R\" if node.color == \"RED\" else \"B\"\n            print(f\"{node.data}({color})\", end=\" \")\n            if node.left:\n                self.print_(node.left)\n            if node.right:\n                self.print_(node.right)\n\n# Тест\nif __name__ == \"__main__\":\n    tree = Tree()\n    for val in [10, 20, 30, 5, 3, 7]:\n        tree.insert(val)\n\n\nВставляем 10\nПосле вставки:\n10(B) \n\nВставляем 20\nПосле вставки до балансировки:\n10(B) 20(R) \nПосле балансировки:\n10(B) 20(R) \n\nВставляем 30\nПосле вставки до балансировки:\n10(B) 20(R) 30(R) \nCase 3: большой поворот\nБольшой левый поворот вокруг 10\nМалый левый поворот вокруг 10\nПосле балансировки:\n20(B) 10(R) 30(R) \n\nВставляем 5\nПосле вставки до балансировки:\n20(B) 10(R) 5(R) 30(R) \nCase 1: дядя красный\nПосле балансировки:\n20(B) 10(B) 5(R) 30(B) \n\nВставляем 3\nПосле вставки до балансировки:\n20(B) 10(B) 5(R) 3(R) 30(B) \nCase 3: большой поворот\nБольшой правый поворот вокруг 10\nМалый правый поворот вокруг 10\nПосле балансировки:\n20(B) 5(B) 3(R) 10(R) 30(B) \n\nВставляем 7\nПосле вставки до балансировки:\n20(B) 5(B) 3(R) 10(R) 7(R) 30(B) \nCase 1: дядя красный\nПосле балансировки:\n20(B) 5(R) 3(B) 10(B) 7(R) 30(B)",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Алгоритмы и струкутры данных</span>"
    ]
  },
  {
    "objectID": "Алгоритмы_HW.html#задача-4.-найти-максимальную-прибыль.",
    "href": "Алгоритмы_HW.html#задача-4.-найти-максимальную-прибыль.",
    "title": "13  Алгоритмы и струкутры данных",
    "section": "13.4 Задача 4. Найти максимальную прибыль.",
    "text": "13.4 Задача 4. Найти максимальную прибыль.\nУ вас есть данные о ценах акций за n дней в виде массива prices. Вы можете совершить не более k сделок (покупка + продажа = 1 сделка).\nНайдите максимальную прибыль, которую можно получить, соблюдая правила: - Нельзя совершать несколько сделок одновременно (нельзя купить и продать в один и тот же день) - Нельзя покупать, если уже есть купленные акции - Можно совершать любое количество сделок, но не более k\nПример:\nprices = [3, 2, 6, 5, 0, 3], k = 2\nМаксимальная прибыль: 7\nОбъяснение:\nПокупка в день 2 (цена 2), продажа в день 3 (цена 6) → прибыль 4\nПокупка в день 5 (цена 0), продажа в день 6 (цена 3) → прибыль 3\nИтого: 4 + 3 = 7\n\nprices, k = [3, 2, 6, 5, 0, 3], 2\n\n\nimport matplotlib.pyplot as plt\nplt.bar(range(1,len(prices)+1),prices)\n\n\n\n\n\n\n\n\n\ndef dynamic_max(prices, k):\n    n = len(prices)\n    df = [[0] * n for _ in range(k+1)]\n    for transaction in range(1, k + 1):\n        max_balance = -prices[0] #максимальный баланс после покупки акции\n        for day in range(1, n):\n            # продавать ли? берем максимум из прибыли вчера и цены сегодня+баланс после покупки\n            df[transaction][day] = max(df[transaction][day - 1], prices[day] + max_balance)\n            # покупать ли? берем текущегго максимума и  прибыли от прошлых сделок - цена сегодня\n            max_balance = max(max_balance, df[transaction - 1][day] - prices[day])\n    for transaction in df:\n        print(transaction)\n    return df[k][n - 1]\n\n\nprint(prices)\ndynamic_max(prices,k)\n\n[3, 2, 6, 5, 0, 3, 0]\n[0, 0, 0, 0, 0, 0, 0]\n[0, 0, 4, 4, 4, 4, 4]\n[0, 0, 4, 4, 4, 7, 7]\n\n\n7",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Алгоритмы и струкутры данных</span>"
    ]
  },
  {
    "objectID": "Алгоритмы_HW.html#задача-5.-в-какой-день-было-больше-всего-посетителей",
    "href": "Алгоритмы_HW.html#задача-5.-в-какой-день-было-больше-всего-посетителей",
    "title": "13  Алгоритмы и струкутры данных",
    "section": "13.5 Задача 5. В какой день было больше всего посетителей?",
    "text": "13.5 Задача 5. В какой день было больше всего посетителей?\nДана информация о времени заезда и отъезда посетителей отеля. Необходимо определить, в какой день посетителей в отеле единомоментно находилось больше всего.\nПример входных данных (один элемент данного листа – кортеж, содержащий дату заезда и отъезда одного посетителя): [(“2024-09-15”, “2024-09-15”), (“2024-09-14”, “2024-09-21”)]\n\n#память О(n), сложность O(nlog(n)) из-за сортировки\nL = [(\"2024-09-15\", \"2024-09-15\"), (\"2024-09-14\", \"2024-09-21\")]\ndef max_booking(L):\n    events = []\n    for (inn, out) in L:\n        events.append((inn, 1))   # прибытие\n        events.append((out, -1))\n\n    max_occupancy = 0\n    current_occupancy = 0\n    max_day = None\n    \n    events = sorted(events, key=lambda x: x[0])\n    # Обрабатываем события в хронологическом порядке\n    for day, event_type in events:\n        current_occupancy += event_type\n\n        # Обновляем максимум если нашли новый\n        if current_occupancy &gt; max_occupancy:\n            max_occupancy = current_occupancy\n            max_day = day\n    \n    return max_day, max_occupancy\n\nmax_booking(L)\n\n('2024-09-15', 2)",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Алгоритмы и струкутры данных</span>"
    ]
  },
  {
    "objectID": "Алгоритмы_HW.html#задача-6.-реализовать-алгоритм-беллмана-форда-для-произвольного-графа.",
    "href": "Алгоритмы_HW.html#задача-6.-реализовать-алгоритм-беллмана-форда-для-произвольного-графа.",
    "title": "13  Алгоритмы и струкутры данных",
    "section": "13.6 Задача 6. Реализовать алгоритм Беллмана-Форда для произвольного графа.",
    "text": "13.6 Задача 6. Реализовать алгоритм Беллмана-Форда для произвольного графа.\nАлгоритм Беллмана-Форда (Bellman-Ford algorithm) позволяет решить зада- чу о кратчайшем пути из одной вершины в общем случае, когда вес каждого из ребер может быть отрицательным.\nБез потери общности можно предположить, что если ведется поиск кратчайших путей, они не содержат циклов.\nДля заданного взвешенного ориентированного графа G = (V,E) с истоком s и весовой функцией w : Е → R алгоритм Белл- мана-Форда возвращает логическое значение, указывающее на то, содержится ли в графе цикл с отрицательным весом, достижимый из истока . Если такой цикл существует, в алгоритме указывается, что решения не существует. Если же таких циклов нет, алгоритм выдает кратчайшие пути и их вес.\nПоскольку в любой ациклический путь в графе G = (V, E) входит не более |V| различных вершин, в нем также содержится не более |V| - 1 ребер. Таким образом, можно ограничиться рассмотрением кратчайших путей, состоящих не более чем из |V| - 1 ребер.\nАлгоритм Беллмана-Форда (Bellman-Ford algorithm) позволяет решить зада- чу о кратчайшем пути из одной вершины в общем случае, когда вес каждого из ребер может быть отрицательным.\nАлгоритм Беллмана-Форда завершает свою работу в течение времени О (V E), поскольку инициализация в строке 1 занимает время O(V), на каждый из |V| - 1 проходов по ребрам требуется время О (Е), а на выполнение цикла for ниже - время О (Е).\n\n\n\ngraph\n\n\n\nimport math\n\ndef Bellman_Ford(graph, edges, source):\n    distances = [math.inf] * len(graph)\n    distances[source] = 0\n    \n    operations = 0\n    \n    # Основной цикл релаксации\n    for _ in range(len(graph) - 1):\n        updated = False\n        for u, v, weight in edges:\n            operations += 1 \n            if distances[u] != math.inf and distances[u] + weight &lt; distances[v]:\n                distances[v] = distances[u] + weight\n                updated = True\n        \n        if not updated:\n            break\n    \n    # Проверка на отрицательные циклы\n    for u, v, weight in edges:\n        operations += 1\n        if distances[u] != math.inf and distances[u] + weight &lt; distances[v]:\n            return None, operations\n    \n    return distances, operations\n\n\nimport random\n# Граф\ngraph = [[0]*5 for _ in range(5)]\ngraph[0][1] = 6\ngraph[0][2] = 7\ngraph[1][2] = 8\ngraph[1][3] = 5\ngraph[1][4] = -4\ngraph[2][3] = -3\ngraph[2][4] = 9\ngraph[3][1] = -2\ngraph[4][0] = 2\ngraph[4][3] = 7\n\n# Базовые ребра\nbase_edges = []\nfor i in range(len(graph)):\n    for j in range(len(graph[i])):\n        if graph[i][j] != 0:\n            base_edges.append((i, j, graph[i][j]))\n\nfor i in range(5):\n    if i == 0:\n        edges = base_edges.copy()  # исходный порядок\n        name = \"Исходный порядок\"\n    else:\n        edges = base_edges.copy()\n        random.shuffle(edges)  # случайный порядок\n        name = f\"Случайный порядок {i}\"\n    \n    result, operations = Bellman_Ford(graph, edges, 0)\n    print(f\"{name}: {operations} операций\")\n    print(f\"Результат: {result}\\n\")\n\n\nИсходный порядок: 40 операций\nРезультат: [0, 2, 7, 4, -2]\n\nСлучайный порядок 1: 50 операций\nРезультат: [0, 2, 7, 4, -2]\n\nСлучайный порядок 2: 40 операций\nРезультат: [0, 2, 7, 4, -2]\n\nСлучайный порядок 3: 50 операций\nРезультат: [0, 2, 7, 4, -2]\n\nСлучайный порядок 4: 50 операций\nРезультат: [0, 2, 7, 4, -2]",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Алгоритмы и струкутры данных</span>"
    ]
  },
  {
    "objectID": "Интерпретация.html",
    "href": "Интерпретация.html",
    "title": "14  Анализ клинических данных",
    "section": "",
    "text": "14.1 Постановка задачи\nНа основе клинического описания и данных полного геномного секвенирования (WGS) предположить генетическую причину состояния пробанда(ов), уточнить/пересмотреть диагноз и подготовить короткую презентацию из нескольких слайдов с ходом рассуждений и описанием выявленного(ых) варианта(ов).",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Анализ клинических данных</span>"
    ]
  },
  {
    "objectID": "Интерпретация.html#план-работы",
    "href": "Интерпретация.html#план-работы",
    "title": "14  Анализ клинических данных",
    "section": "14.2 План работы",
    "text": "14.2 План работы\n\n14.2.1 Анализ фенотипа пробанда\n\nВыделение ключевых клинических признаков (неврологические, соматические, особенности роста и развития, семейный/репродуктивный анамнез).\n\n\n\n14.2.2 Формулировка гипотез о генетической природе заболевания\n\nСоздание рабочих гипотез: возможный тип наследования, круг генов-кандидатов / синдромов.\nОбоснование выбора спектра диагнозов/генов на основе фенотипа и семейного анамнеза.\n\n\n\n14.2.3 Анализ данных WGS для уточнения диагноза\n\nАнализ VCF-файлов семьи.\nВыбор варианта(ов), потенциально объясняющих фенотип пробанда.\nУказание гена, типа варианта, модели наследования, предполагаемого механизма (LoF, missense, splice и т.д.).\nСопоставление найденного варианта с литературными и базами данных (OMIM, ClinVar и др.).\n\n\n\n14.2.4 Формулировка итогового заключения\nВ нем не стоит рекомендовать человеку процедуры или обследования - это делает врач, с которым вы вместе ведете пациента.\n\n\n14.2.5 Подготовка презентации\n\nСлайд 1: Краткое описание клинического случая (пробанд, основные симптомы, семейный/репродуктивный анамнез).\nСлайд 2: Диагностические гипотезы и ход рассуждений (обоснование выбора гена/синдрома, тип наследования).\nСлайд 3: Найденный вариант(ы): ген, тип, zygosity, модель наследования, аргументы «за» его причинную роль.\nСлайд 4 (опционально): Итоговое заключение, уточнённый диагноз, генетические риски для семьи, открытые вопросы.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Анализ клинических данных</span>"
    ]
  },
  {
    "objectID": "Интерпретация.html#диагностические-гипотезы-на-основе-фенотипа",
    "href": "Интерпретация.html#диагностические-гипотезы-на-основе-фенотипа",
    "title": "14  Анализ клинических данных",
    "section": "14.3 Диагностические гипотезы (на основе фенотипа)",
    "text": "14.3 Диагностические гипотезы (на основе фенотипа)\nРассматриваются следующие возможные типы наследования:\n\nDe novo доминантная мутация — вероятна при здоровых родителях и сибсах. Потребует подтверждения по Сэнгеру.\nАутосомно-рецессивное наследование — оба родителя являются здоровыми носителями\nX-сцепленное рецессивное наследование — мать как возможная носительница, пробанд мужского пола.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Анализ клинических данных</span>"
    ]
  },
  {
    "objectID": "Интерпретация.html#стратегия-анализа-данных-wgs-и-реализация-на-python",
    "href": "Интерпретация.html#стратегия-анализа-данных-wgs-и-реализация-на-python",
    "title": "14  Анализ клинических данных",
    "section": "14.4 Стратегия анализа данных WGS и реализация на Python",
    "text": "14.4 Стратегия анализа данных WGS и реализация на Python\n\n14.4.1 Инициализация и загрузка данных\n\nimport pandas as pd\nimport numpy as np\n\n# Загружаем данные WGS из VCF-файла, сконвертированного в табличный формат\ndf = pd.read_csv('/home/florenskayalk/64family.txt', sep='\\t', usecols=[\n    '#[1]CHROM', '[2]POS', '[3]ID', '[8]SYMBOL', '[15]Consequence',\n    '[21]AF_joint', '[29]CLNSIG', '[31]CLNDN', '[35]CADD_PHRED',\n    '[43]000028002000:GT', '[46]000028003810:GT', '[49]000028001980:GT', '[52]000028001990:GT'\n])\nprint(f\"Всего вариантов: {len(df)}\")\n\n\n\n14.4.2 Подготовка данных CADD и AF\n\ndef parse(cadd_str):\n    try:\n        if pd.isna(cadd_str):\n            return None\n        return float(str(cadd_str).replace(',', '.').strip())\n    except:\n        return None\n\ndf['CADD_num'] = df['[35]CADD_PHRED'].apply(parse)\ndf['[21]AF_joint'] = df['[21]AF_joint'].apply(parse)\n\n\n\n14.4.3 Первичный отбор вариантов\n\nИсключение референсных генотипов у пробанда.\nФильтрация по частоте в популяции (AF &lt; 1%).\nОтбор функционально значимых вариантов (исключение синонимичных и интронных) нельзя исключать интронные варианты!\n\n\n# Только варианты у пробанда (не референсные)\nproband_gt = df['[43]000028002000:GT']\ndf = df[~proband_gt.isin(['0/0', './.', '0|0', '.|.'])]\n\n# Исключаем частые популяционные варианты (порог можно менять)\ndf = df[pd.to_numeric(df['[21]AF_joint'], errors='coerce').fillna(0) &lt; 0.01]\n\n\nprint(f\"Вариантов после базовой фильтрации: {len(df)}\")\n\n\n\n14.4.4 Поиск de novo мутаций\n\nПриоритетный анализ.\nКритерии: вариант присутствует у пробанда, отсутствует у обоих родителей и здоровго сибса.\n\n\ndef is_de_novo(row):\n    proband = row['[43]000028002000:GT']\n    mother = row['[49]000028001980:GT']\n    father = row['[52]000028001990:GT']\n    sibs = row['[46]000028003810:GT']\n    # У пробанда есть вариант, у родителей оба аллеля референсные\n    if proband not in ['0/0', './.', '0|0', '.|.']:\n        if mother in ['0/0', '0|0'] and father in ['0/0', '0|0'] and sibs in ['0/0', '0|0']:\n            return 'YES'\n    return 'NO'\n\ndf['de_novo'] = df.apply(is_de_novo, axis=1)\ndf_de_novo = df[df['de_novo'] == 'YES'].copy()\nprint(f\"Кандидатов de novo: {len(df_de_novo)}\")\n\n\n\n14.4.5 Анализ X-сцепленных вариантов\n\nПоиск гемизиготных вариантов у пробанда (мужского пола).\nПроверка статуса носительства у матери (гетерозигота).\n\n\ndf_x = df[df['#[1]CHROM'] == 'chrX'].copy()\nif not df_x.empty:\n    print(f\"\\nВариантов на X-хромосоме: {len(df_x)}\")\n    # Ищем гемизиготные у пробанда и гетерозиготные у матери\n    x_linked_candidates = df_x[\n        (df_x['[43]000028002000:GT'].isin(['1', '1/1', '1|1'])) &  # Гемизигота у мальчика\n        (df_x['[49]000028001980:GT'].isin(['0/1', '0|1', '1/0', '1|0']))  # Гетерозигота у матери\n    ]\n    print(f\"Кандидатов X-сцепленных (у пробанда гемизигота, у матери носительство): {len(x_linked_candidates)}\")\n\n\n\n14.4.6 Выявление аутосомно-рецессивных вариантов\n\nПоиск компаунд-гетерозигот или гомозигот.\nКритерии: наличие ≥2 нереференсных вариантов в одном гене с CADD &gt; 20.\n\n\n# Сначала найдем все гены, где у пробанда &gt;=2 нереференсных варианта\nmask_multiple_in_gene = df.duplicated(subset='[8]SYMBOL', keep=False)\ndf_multiple = df[mask_multiple_in_gene].copy()\n\nif not df_multiple.empty:\n    # Для каждого гена смотрим генотипы в семье\n    recessive_candidates = []\n    for gene, gene_df in df_multiple.groupby('[8]SYMBOL'):\n        # У пробанда в этом гене два разных патогенных варианта?\n        # Простая эвристика: есть хотя бы два варианта с CADD &gt; 20\n        hi_vars = gene_df[gene_df['CADD_num'] &gt; 20]\n        if len(hi_vars) &gt;= 2:\n            recessive_candidates.append(gene)\n    \n    print(f\"\\nГены-кандидаты для рецессивного наследования (&gt;=2 варианта с CADD&gt;20): {recessive_candidates}\")\n\n\n\n14.4.7 Прицельный поиск по генам-кандидатам\n\nРучная проверка ключевых генов, связанных с клиническим фенотипом (например, гены RASопатий, ихтиоза, неврологических нарушений).\n\n\n# Составим список генов, связанных с фенотипом\ncandidate_genes = ['NF1', 'BRAF', 'KRAS', 'HRAS', 'NRAS', 'MAP2K1', 'MAP2K2',  # RASопатии\n                   'FLG', 'KRT1', 'KRT10', 'ALOX12B', 'ALOXE3', 'TGM1',  # Ихтиоз\n                   'MECP2', 'CDKL5', 'SYNGAP1', 'SCN1A', 'SCN2A',  # Неврологические\n                   'PTEN'  # Схожие черты\n                  ]\n\nprint(f\"\\n--- Поиск по известным генам-кандидатам ({len(candidate_genes)} генов) ---\")\ndf_candidate = df[df['[8]SYMBOL'].isin(candidate_genes)].copy()\nif not df_candidate.empty:\n    print(\"Найдены варианты в генах-кандидатах\")\nelse:\n    print(\"В известных генах-кандидатах вариантов не найдено.\")",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Анализ клинических данных</span>"
    ]
  }
]